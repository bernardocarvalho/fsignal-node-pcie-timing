// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __SCADUtils_hh__
#define __SCADUtils_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_SCADUtils
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_SCADUtils
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_SCADUtils
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE org

_CORBA_MODULE_BEG

  _CORBA_MODULE cfn

  _CORBA_MODULE_BEG

    _CORBA_MODULE scad

    _CORBA_MODULE_BEG

      _CORBA_MODULE core

      _CORBA_MODULE_BEG

        _CORBA_MODULE corba

        _CORBA_MODULE_BEG

          _CORBA_MODULE util

          _CORBA_MODULE_BEG

            struct Property {
              typedef _CORBA_ConstrType_Variable_Var<Property> _var_type;

              
              CORBA::WString_member name;

              CORBA::Any value;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef Property::_var_type Property_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< Property,Property_var > Property_out;

            struct Time {
              typedef _CORBA_ConstrType_Fix_Var<Time> _var_type;

              
              CORBA::Short picos;

              CORBA::Short nanos;

              CORBA::Short micros;

              CORBA::Short millis;

              CORBA::Octet seconds;

              CORBA::Octet minutes;

              CORBA::Octet hours;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef Time::_var_type Time_var;

            typedef Time& Time_out;

            struct Date {
              typedef _CORBA_ConstrType_Fix_Var<Date> _var_type;

              
              CORBA::Octet day;

              CORBA::Octet month;

              CORBA::Short year;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef Date::_var_type Date_var;

            typedef Date& Date_out;

            struct TimeStamp {
              typedef _CORBA_ConstrType_Fix_Var<TimeStamp> _var_type;

              
              Date dt;

              Time tm;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef TimeStamp::_var_type TimeStamp_var;

            typedef TimeStamp& TimeStamp_out;

            struct Comment {
              typedef _CORBA_ConstrType_Variable_Var<Comment> _var_type;

              
              CORBA::WString_member username;

              TimeStamp time;

              CORBA::WString_member com;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef Comment::_var_type Comment_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< Comment,Comment_var > Comment_out;

            class CommentList_var;

            class CommentList : public _CORBA_Unbounded_Sequence< Comment >  {
            public:
              typedef CommentList_var _var_type;
              inline CommentList() {}
              inline CommentList(const CommentList& _s)
                : _CORBA_Unbounded_Sequence< Comment > (_s) {}

              inline CommentList(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< Comment > (_max) {}
              inline CommentList(_CORBA_ULong _max, _CORBA_ULong _len, Comment* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< Comment > (_max, _len, _val, _rel) {}

            

              inline CommentList& operator = (const CommentList& _s) {
                _CORBA_Unbounded_Sequence< Comment > ::operator=(_s);
                return *this;
              }
            };

            class CommentList_out;

            class CommentList_var {
            public:
              inline CommentList_var() : _pd_seq(0) {}
              inline CommentList_var(CommentList* _s) : _pd_seq(_s) {}
              inline CommentList_var(const CommentList_var& _s) {
                if( _s._pd_seq )  _pd_seq = new CommentList(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~CommentList_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline CommentList_var& operator = (CommentList* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline CommentList_var& operator = (const CommentList_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new CommentList;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline Comment& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline CommentList* operator -> () { return _pd_seq; }
              inline const CommentList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator CommentList& () const { return *_pd_seq; }
#else
              inline operator const CommentList& () const { return *_pd_seq; }
              inline operator CommentList& () { return *_pd_seq; }
#endif
                
              inline const CommentList& in() const { return *_pd_seq; }
              inline CommentList&       inout()    { return *_pd_seq; }
              inline CommentList*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline CommentList* _retn() { CommentList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class CommentList_out;
              
            private:
              CommentList* _pd_seq;
            };

            class CommentList_out {
            public:
              inline CommentList_out(CommentList*& _s) : _data(_s) { _data = 0; }
              inline CommentList_out(CommentList_var& _s)
                : _data(_s._pd_seq) { _s = (CommentList*) 0; }
              inline CommentList_out(const CommentList_out& _s) : _data(_s._data) {}
              inline CommentList_out& operator = (const CommentList_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline CommentList_out& operator = (CommentList* _s) {
                _data = _s;
                return *this;
              }
              inline operator CommentList*&()  { return _data; }
              inline CommentList*& ptr()       { return _data; }
              inline CommentList* operator->() { return _data; }

              inline Comment& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              CommentList*& _data;

            private:
              CommentList_out();
              CommentList_out& operator=(const CommentList_var&);
            };

            class TimeStampList_var;

            class TimeStampList : public _CORBA_Unbounded_Sequence< TimeStamp >  {
            public:
              typedef TimeStampList_var _var_type;
              inline TimeStampList() {}
              inline TimeStampList(const TimeStampList& _s)
                : _CORBA_Unbounded_Sequence< TimeStamp > (_s) {}

              inline TimeStampList(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< TimeStamp > (_max) {}
              inline TimeStampList(_CORBA_ULong _max, _CORBA_ULong _len, TimeStamp* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< TimeStamp > (_max, _len, _val, _rel) {}

            

              inline TimeStampList& operator = (const TimeStampList& _s) {
                _CORBA_Unbounded_Sequence< TimeStamp > ::operator=(_s);
                return *this;
              }
            };

            class TimeStampList_out;

            class TimeStampList_var {
            public:
              inline TimeStampList_var() : _pd_seq(0) {}
              inline TimeStampList_var(TimeStampList* _s) : _pd_seq(_s) {}
              inline TimeStampList_var(const TimeStampList_var& _s) {
                if( _s._pd_seq )  _pd_seq = new TimeStampList(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~TimeStampList_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline TimeStampList_var& operator = (TimeStampList* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline TimeStampList_var& operator = (const TimeStampList_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new TimeStampList;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline TimeStamp& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline TimeStampList* operator -> () { return _pd_seq; }
              inline const TimeStampList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator TimeStampList& () const { return *_pd_seq; }
#else
              inline operator const TimeStampList& () const { return *_pd_seq; }
              inline operator TimeStampList& () { return *_pd_seq; }
#endif
                
              inline const TimeStampList& in() const { return *_pd_seq; }
              inline TimeStampList&       inout()    { return *_pd_seq; }
              inline TimeStampList*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline TimeStampList* _retn() { TimeStampList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class TimeStampList_out;
              
            private:
              TimeStampList* _pd_seq;
            };

            class TimeStampList_out {
            public:
              inline TimeStampList_out(TimeStampList*& _s) : _data(_s) { _data = 0; }
              inline TimeStampList_out(TimeStampList_var& _s)
                : _data(_s._pd_seq) { _s = (TimeStampList*) 0; }
              inline TimeStampList_out(const TimeStampList_out& _s) : _data(_s._data) {}
              inline TimeStampList_out& operator = (const TimeStampList_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline TimeStampList_out& operator = (TimeStampList* _s) {
                _data = _s;
                return *this;
              }
              inline operator TimeStampList*&()  { return _data; }
              inline TimeStampList*& ptr()       { return _data; }
              inline TimeStampList* operator->() { return _data; }

              inline TimeStamp& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              TimeStampList*& _data;

            private:
              TimeStampList_out();
              TimeStampList_out& operator=(const TimeStampList_var&);
            };

            class PropertyList_var;

            class PropertyList : public _CORBA_Unbounded_Sequence< Property >  {
            public:
              typedef PropertyList_var _var_type;
              inline PropertyList() {}
              inline PropertyList(const PropertyList& _s)
                : _CORBA_Unbounded_Sequence< Property > (_s) {}

              inline PropertyList(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< Property > (_max) {}
              inline PropertyList(_CORBA_ULong _max, _CORBA_ULong _len, Property* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< Property > (_max, _len, _val, _rel) {}

            

              inline PropertyList& operator = (const PropertyList& _s) {
                _CORBA_Unbounded_Sequence< Property > ::operator=(_s);
                return *this;
              }
            };

            class PropertyList_out;

            class PropertyList_var {
            public:
              inline PropertyList_var() : _pd_seq(0) {}
              inline PropertyList_var(PropertyList* _s) : _pd_seq(_s) {}
              inline PropertyList_var(const PropertyList_var& _s) {
                if( _s._pd_seq )  _pd_seq = new PropertyList(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~PropertyList_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline PropertyList_var& operator = (PropertyList* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline PropertyList_var& operator = (const PropertyList_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new PropertyList;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline Property& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline PropertyList* operator -> () { return _pd_seq; }
              inline const PropertyList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator PropertyList& () const { return *_pd_seq; }
#else
              inline operator const PropertyList& () const { return *_pd_seq; }
              inline operator PropertyList& () { return *_pd_seq; }
#endif
                
              inline const PropertyList& in() const { return *_pd_seq; }
              inline PropertyList&       inout()    { return *_pd_seq; }
              inline PropertyList*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline PropertyList* _retn() { PropertyList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class PropertyList_out;
              
            private:
              PropertyList* _pd_seq;
            };

            class PropertyList_out {
            public:
              inline PropertyList_out(PropertyList*& _s) : _data(_s) { _data = 0; }
              inline PropertyList_out(PropertyList_var& _s)
                : _data(_s._pd_seq) { _s = (PropertyList*) 0; }
              inline PropertyList_out(const PropertyList_out& _s) : _data(_s._data) {}
              inline PropertyList_out& operator = (const PropertyList_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline PropertyList_out& operator = (PropertyList* _s) {
                _data = _s;
                return *this;
              }
              inline operator PropertyList*&()  { return _data; }
              inline PropertyList*& ptr()       { return _data; }
              inline PropertyList* operator->() { return _data; }

              inline Property& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              PropertyList*& _data;

            private:
              PropertyList_out();
              PropertyList_out& operator=(const PropertyList_var&);
            };

            class CharArray_var;

            class CharArray : public _CORBA_Unbounded_Sequence_WChar {
            public:
              typedef CharArray_var _var_type;
              inline CharArray() {}
              inline CharArray(const CharArray& _s)
                : _CORBA_Unbounded_Sequence_WChar(_s) {}

              inline CharArray(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence_WChar(_max) {}
              inline CharArray(_CORBA_ULong _max, _CORBA_ULong _len, CORBA::WChar* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence_WChar(_max, _len, _val, _rel) {}

            

              inline CharArray& operator = (const CharArray& _s) {
                _CORBA_Unbounded_Sequence_WChar::operator=(_s);
                return *this;
              }
            };

            class CharArray_out;

            class CharArray_var {
            public:
              inline CharArray_var() : _pd_seq(0) {}
              inline CharArray_var(CharArray* _s) : _pd_seq(_s) {}
              inline CharArray_var(const CharArray_var& _s) {
                if( _s._pd_seq )  _pd_seq = new CharArray(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~CharArray_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline CharArray_var& operator = (CharArray* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline CharArray_var& operator = (const CharArray_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new CharArray;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline CORBA::WChar& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline CharArray* operator -> () { return _pd_seq; }
              inline const CharArray* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator CharArray& () const { return *_pd_seq; }
#else
              inline operator const CharArray& () const { return *_pd_seq; }
              inline operator CharArray& () { return *_pd_seq; }
#endif
                
              inline const CharArray& in() const { return *_pd_seq; }
              inline CharArray&       inout()    { return *_pd_seq; }
              inline CharArray*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline CharArray* _retn() { CharArray* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class CharArray_out;
              
            private:
              CharArray* _pd_seq;
            };

            class CharArray_out {
            public:
              inline CharArray_out(CharArray*& _s) : _data(_s) { _data = 0; }
              inline CharArray_out(CharArray_var& _s)
                : _data(_s._pd_seq) { _s = (CharArray*) 0; }
              inline CharArray_out(const CharArray_out& _s) : _data(_s._data) {}
              inline CharArray_out& operator = (const CharArray_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline CharArray_out& operator = (CharArray* _s) {
                _data = _s;
                return *this;
              }
              inline operator CharArray*&()  { return _data; }
              inline CharArray*& ptr()       { return _data; }
              inline CharArray* operator->() { return _data; }

              inline CORBA::WChar& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              CharArray*& _data;

            private:
              CharArray_out();
              CharArray_out& operator=(const CharArray_var&);
            };

            class ByteArray_var;

            class ByteArray : public _CORBA_Unbounded_Sequence_Octet {
            public:
              typedef ByteArray_var _var_type;
              inline ByteArray() {}
              inline ByteArray(const ByteArray& _s)
                : _CORBA_Unbounded_Sequence_Octet(_s) {}

              inline ByteArray(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence_Octet(_max) {}
              inline ByteArray(_CORBA_ULong _max, _CORBA_ULong _len, CORBA::Octet* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence_Octet(_max, _len, _val, _rel) {}

            

              inline ByteArray& operator = (const ByteArray& _s) {
                _CORBA_Unbounded_Sequence_Octet::operator=(_s);
                return *this;
              }
            };

            class ByteArray_out;

            class ByteArray_var {
            public:
              inline ByteArray_var() : _pd_seq(0) {}
              inline ByteArray_var(ByteArray* _s) : _pd_seq(_s) {}
              inline ByteArray_var(const ByteArray_var& _s) {
                if( _s._pd_seq )  _pd_seq = new ByteArray(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~ByteArray_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline ByteArray_var& operator = (ByteArray* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline ByteArray_var& operator = (const ByteArray_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new ByteArray;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline CORBA::Octet& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline ByteArray* operator -> () { return _pd_seq; }
              inline const ByteArray* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator ByteArray& () const { return *_pd_seq; }
#else
              inline operator const ByteArray& () const { return *_pd_seq; }
              inline operator ByteArray& () { return *_pd_seq; }
#endif
                
              inline const ByteArray& in() const { return *_pd_seq; }
              inline ByteArray&       inout()    { return *_pd_seq; }
              inline ByteArray*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline ByteArray* _retn() { ByteArray* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class ByteArray_out;
              
            private:
              ByteArray* _pd_seq;
            };

            class ByteArray_out {
            public:
              inline ByteArray_out(ByteArray*& _s) : _data(_s) { _data = 0; }
              inline ByteArray_out(ByteArray_var& _s)
                : _data(_s._pd_seq) { _s = (ByteArray*) 0; }
              inline ByteArray_out(const ByteArray_out& _s) : _data(_s._data) {}
              inline ByteArray_out& operator = (const ByteArray_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline ByteArray_out& operator = (ByteArray* _s) {
                _data = _s;
                return *this;
              }
              inline operator ByteArray*&()  { return _data; }
              inline ByteArray*& ptr()       { return _data; }
              inline ByteArray* operator->() { return _data; }

              inline CORBA::Octet& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              ByteArray*& _data;

            private:
              ByteArray_out();
              ByteArray_out& operator=(const ByteArray_var&);
            };

            class ByteArrayD_var;

            class ByteArrayD : public _CORBA_Unbounded_Sequence< ByteArray >  {
            public:
              typedef ByteArrayD_var _var_type;
              inline ByteArrayD() {}
              inline ByteArrayD(const ByteArrayD& _s)
                : _CORBA_Unbounded_Sequence< ByteArray > (_s) {}

              inline ByteArrayD(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< ByteArray > (_max) {}
              inline ByteArrayD(_CORBA_ULong _max, _CORBA_ULong _len, ByteArray* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< ByteArray > (_max, _len, _val, _rel) {}

            

              inline ByteArrayD& operator = (const ByteArrayD& _s) {
                _CORBA_Unbounded_Sequence< ByteArray > ::operator=(_s);
                return *this;
              }
            };

            class ByteArrayD_out;

            class ByteArrayD_var {
            public:
              inline ByteArrayD_var() : _pd_seq(0) {}
              inline ByteArrayD_var(ByteArrayD* _s) : _pd_seq(_s) {}
              inline ByteArrayD_var(const ByteArrayD_var& _s) {
                if( _s._pd_seq )  _pd_seq = new ByteArrayD(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~ByteArrayD_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline ByteArrayD_var& operator = (ByteArrayD* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline ByteArrayD_var& operator = (const ByteArrayD_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new ByteArrayD;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline ByteArray& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline ByteArrayD* operator -> () { return _pd_seq; }
              inline const ByteArrayD* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator ByteArrayD& () const { return *_pd_seq; }
#else
              inline operator const ByteArrayD& () const { return *_pd_seq; }
              inline operator ByteArrayD& () { return *_pd_seq; }
#endif
                
              inline const ByteArrayD& in() const { return *_pd_seq; }
              inline ByteArrayD&       inout()    { return *_pd_seq; }
              inline ByteArrayD*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline ByteArrayD* _retn() { ByteArrayD* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class ByteArrayD_out;
              
            private:
              ByteArrayD* _pd_seq;
            };

            class ByteArrayD_out {
            public:
              inline ByteArrayD_out(ByteArrayD*& _s) : _data(_s) { _data = 0; }
              inline ByteArrayD_out(ByteArrayD_var& _s)
                : _data(_s._pd_seq) { _s = (ByteArrayD*) 0; }
              inline ByteArrayD_out(const ByteArrayD_out& _s) : _data(_s._data) {}
              inline ByteArrayD_out& operator = (const ByteArrayD_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline ByteArrayD_out& operator = (ByteArrayD* _s) {
                _data = _s;
                return *this;
              }
              inline operator ByteArrayD*&()  { return _data; }
              inline ByteArrayD*& ptr()       { return _data; }
              inline ByteArrayD* operator->() { return _data; }

              inline ByteArray& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              ByteArrayD*& _data;

            private:
              ByteArrayD_out();
              ByteArrayD_out& operator=(const ByteArrayD_var&);
            };

            class StringList_var;

            class StringList : public _CORBA_Unbounded_Sequence_WString {
            public:
              typedef StringList_var _var_type;
              inline StringList() {}
              inline StringList(const StringList& _s)
                : _CORBA_Unbounded_Sequence_WString(_s) {}

              inline StringList(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence_WString(_max) {}
              inline StringList(_CORBA_ULong _max, _CORBA_ULong _len, CORBA::WChar** _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence_WString(_max, _len, _val, _rel) {}

            

              inline StringList& operator = (const StringList& _s) {
                _CORBA_Unbounded_Sequence_WString::operator=(_s);
                return *this;
              }
            };

            class StringList_out;

            class StringList_var {
            public:
              inline StringList_var() : _pd_seq(0) {}
              inline StringList_var(StringList* _s) : _pd_seq(_s) {}
              inline StringList_var(const StringList_var& _s) {
                if( _s._pd_seq )  _pd_seq = new StringList(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~StringList_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline StringList_var& operator = (StringList* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline StringList_var& operator = (const StringList_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new StringList;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline _CORBA_WString_element operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline StringList* operator -> () { return _pd_seq; }
              inline const StringList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator StringList& () const { return *_pd_seq; }
#else
              inline operator const StringList& () const { return *_pd_seq; }
              inline operator StringList& () { return *_pd_seq; }
#endif
                
              inline const StringList& in() const { return *_pd_seq; }
              inline StringList&       inout()    { return *_pd_seq; }
              inline StringList*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline StringList* _retn() { StringList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class StringList_out;
              
            private:
              StringList* _pd_seq;
            };

            class StringList_out {
            public:
              inline StringList_out(StringList*& _s) : _data(_s) { _data = 0; }
              inline StringList_out(StringList_var& _s)
                : _data(_s._pd_seq) { _s = (StringList*) 0; }
              inline StringList_out(const StringList_out& _s) : _data(_s._data) {}
              inline StringList_out& operator = (const StringList_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline StringList_out& operator = (StringList* _s) {
                _data = _s;
                return *this;
              }
              inline operator StringList*&()  { return _data; }
              inline StringList*& ptr()       { return _data; }
              inline StringList* operator->() { return _data; }

              inline _CORBA_WString_element operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              StringList*& _data;

            private:
              StringList_out();
              StringList_out& operator=(const StringList_var&);
            };

          _CORBA_MODULE_END

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_org
_CORBA_MODULE_BEG

  _CORBA_MODULE cfn
  _CORBA_MODULE_BEG

    _CORBA_MODULE scad
    _CORBA_MODULE_BEG

      _CORBA_MODULE core
      _CORBA_MODULE_BEG

        _CORBA_MODULE corba
        _CORBA_MODULE_BEG

          _CORBA_MODULE util
          _CORBA_MODULE_BEG

          _CORBA_MODULE_END

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE OBV_org
_CORBA_MODULE_BEG

  _CORBA_MODULE cfn
  _CORBA_MODULE_BEG

    _CORBA_MODULE scad
    _CORBA_MODULE_BEG

      _CORBA_MODULE core
      _CORBA_MODULE_BEG

        _CORBA_MODULE corba
        _CORBA_MODULE_BEG

          _CORBA_MODULE util
          _CORBA_MODULE_BEG

          _CORBA_MODULE_END

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_SCADUtils
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_SCADUtils
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_SCADUtils
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_SCADUtils
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_SCADUtils
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_SCADUtils
#endif

#endif  // __SCADUtils_hh__

