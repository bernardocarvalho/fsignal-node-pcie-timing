// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __SCAD_hh__
#define __SCAD_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_SCAD
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_SCAD
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_SCAD
#endif



#ifndef __SCADUtils_hh_EXTERNAL_GUARD__
#define __SCADUtils_hh_EXTERNAL_GUARD__
#include "SCADUtils.hh"
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE org

_CORBA_MODULE_BEG

  _CORBA_MODULE cfn

  _CORBA_MODULE_BEG

    _CORBA_MODULE scad

    _CORBA_MODULE_BEG

      _CORBA_MODULE core

      _CORBA_MODULE_BEG

        _CORBA_MODULE corba

        _CORBA_MODULE_BEG

          _CORBA_MODULE hardware

          _CORBA_MODULE_BEG

            struct Event {
              typedef _CORBA_ConstrType_Variable_Var<Event> _var_type;

              
              CORBA::LongLong event_unique_id;

              CORBA::WString_member nameUniqueID;

              util::TimeStamp tstamp;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef Event::_var_type Event_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< Event,Event_var > Event_out;

            class EventList_var;

            class EventList : public _CORBA_Unbounded_Sequence< Event >  {
            public:
              typedef EventList_var _var_type;
              inline EventList() {}
              inline EventList(const EventList& _s)
                : _CORBA_Unbounded_Sequence< Event > (_s) {}

              inline EventList(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< Event > (_max) {}
              inline EventList(_CORBA_ULong _max, _CORBA_ULong _len, Event* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< Event > (_max, _len, _val, _rel) {}

            

              inline EventList& operator = (const EventList& _s) {
                _CORBA_Unbounded_Sequence< Event > ::operator=(_s);
                return *this;
              }
            };

            class EventList_out;

            class EventList_var {
            public:
              inline EventList_var() : _pd_seq(0) {}
              inline EventList_var(EventList* _s) : _pd_seq(_s) {}
              inline EventList_var(const EventList_var& _s) {
                if( _s._pd_seq )  _pd_seq = new EventList(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~EventList_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline EventList_var& operator = (EventList* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline EventList_var& operator = (const EventList_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new EventList;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline Event& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline EventList* operator -> () { return _pd_seq; }
              inline const EventList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator EventList& () const { return *_pd_seq; }
#else
              inline operator const EventList& () const { return *_pd_seq; }
              inline operator EventList& () { return *_pd_seq; }
#endif
                
              inline const EventList& in() const { return *_pd_seq; }
              inline EventList&       inout()    { return *_pd_seq; }
              inline EventList*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline EventList* _retn() { EventList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class EventList_out;
              
            private:
              EventList* _pd_seq;
            };

            class EventList_out {
            public:
              inline EventList_out(EventList*& _s) : _data(_s) { _data = 0; }
              inline EventList_out(EventList_var& _s)
                : _data(_s._pd_seq) { _s = (EventList*) 0; }
              inline EventList_out(const EventList_out& _s) : _data(_s._data) {}
              inline EventList_out& operator = (const EventList_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline EventList_out& operator = (EventList* _s) {
                _data = _s;
                return *this;
              }
              inline operator EventList*&()  { return _data; }
              inline EventList*& ptr()       { return _data; }
              inline EventList* operator->() { return _data; }

              inline Event& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              EventList*& _data;

            private:
              EventList_out();
              EventList_out& operator=(const EventList_var&);
            };

            struct NameInfo {
              typedef _CORBA_ConstrType_Variable_Var<NameInfo> _var_type;

              
              CORBA::WString_member nodeUID;

              CORBA::WString_member hwUID;

              CORBA::WString_member parUID;

              CORBA::WString_member name;

              CORBA::WString_member description;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef NameInfo::_var_type NameInfo_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< NameInfo,NameInfo_var > NameInfo_out;

            class NameInfoList_var;

            class NameInfoList : public _CORBA_Unbounded_Sequence< NameInfo >  {
            public:
              typedef NameInfoList_var _var_type;
              inline NameInfoList() {}
              inline NameInfoList(const NameInfoList& _s)
                : _CORBA_Unbounded_Sequence< NameInfo > (_s) {}

              inline NameInfoList(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< NameInfo > (_max) {}
              inline NameInfoList(_CORBA_ULong _max, _CORBA_ULong _len, NameInfo* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< NameInfo > (_max, _len, _val, _rel) {}

            

              inline NameInfoList& operator = (const NameInfoList& _s) {
                _CORBA_Unbounded_Sequence< NameInfo > ::operator=(_s);
                return *this;
              }
            };

            class NameInfoList_out;

            class NameInfoList_var {
            public:
              inline NameInfoList_var() : _pd_seq(0) {}
              inline NameInfoList_var(NameInfoList* _s) : _pd_seq(_s) {}
              inline NameInfoList_var(const NameInfoList_var& _s) {
                if( _s._pd_seq )  _pd_seq = new NameInfoList(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~NameInfoList_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline NameInfoList_var& operator = (NameInfoList* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline NameInfoList_var& operator = (const NameInfoList_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new NameInfoList;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline NameInfo& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline NameInfoList* operator -> () { return _pd_seq; }
              inline const NameInfoList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator NameInfoList& () const { return *_pd_seq; }
#else
              inline operator const NameInfoList& () const { return *_pd_seq; }
              inline operator NameInfoList& () { return *_pd_seq; }
#endif
                
              inline const NameInfoList& in() const { return *_pd_seq; }
              inline NameInfoList&       inout()    { return *_pd_seq; }
              inline NameInfoList*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline NameInfoList* _retn() { NameInfoList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class NameInfoList_out;
              
            private:
              NameInfoList* _pd_seq;
            };

            class NameInfoList_out {
            public:
              inline NameInfoList_out(NameInfoList*& _s) : _data(_s) { _data = 0; }
              inline NameInfoList_out(NameInfoList_var& _s)
                : _data(_s._pd_seq) { _s = (NameInfoList*) 0; }
              inline NameInfoList_out(const NameInfoList_out& _s) : _data(_s._data) {}
              inline NameInfoList_out& operator = (const NameInfoList_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline NameInfoList_out& operator = (NameInfoList* _s) {
                _data = _s;
                return *this;
              }
              inline operator NameInfoList*&()  { return _data; }
              inline NameInfoList*& ptr()       { return _data; }
              inline NameInfoList* operator->() { return _data; }

              inline NameInfo& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              NameInfoList*& _data;

            private:
              NameInfoList_out();
              NameInfoList_out& operator=(const NameInfoList_var&);
            };

          _CORBA_MODULE_END

          _CORBA_MODULE db

          _CORBA_MODULE_BEG

            struct Data {
              typedef _CORBA_ConstrType_Variable_Var<Data> _var_type;

              
              util::TimeStamp tstart;

              util::TimeStamp tend;

              hardware::EventList eList;

              CORBA::WString_member configXML;

              util::ByteArray datab;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef Data::_var_type Data_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< Data,Data_var > Data_out;

            class DataList_var;

            class DataList : public _CORBA_Unbounded_Sequence< Data >  {
            public:
              typedef DataList_var _var_type;
              inline DataList() {}
              inline DataList(const DataList& _s)
                : _CORBA_Unbounded_Sequence< Data > (_s) {}

              inline DataList(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< Data > (_max) {}
              inline DataList(_CORBA_ULong _max, _CORBA_ULong _len, Data* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< Data > (_max, _len, _val, _rel) {}

            

              inline DataList& operator = (const DataList& _s) {
                _CORBA_Unbounded_Sequence< Data > ::operator=(_s);
                return *this;
              }
            };

            class DataList_out;

            class DataList_var {
            public:
              inline DataList_var() : _pd_seq(0) {}
              inline DataList_var(DataList* _s) : _pd_seq(_s) {}
              inline DataList_var(const DataList_var& _s) {
                if( _s._pd_seq )  _pd_seq = new DataList(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~DataList_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline DataList_var& operator = (DataList* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline DataList_var& operator = (const DataList_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new DataList;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline Data& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline DataList* operator -> () { return _pd_seq; }
              inline const DataList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator DataList& () const { return *_pd_seq; }
#else
              inline operator const DataList& () const { return *_pd_seq; }
              inline operator DataList& () { return *_pd_seq; }
#endif
                
              inline const DataList& in() const { return *_pd_seq; }
              inline DataList&       inout()    { return *_pd_seq; }
              inline DataList*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline DataList* _retn() { DataList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class DataList_out;
              
            private:
              DataList* _pd_seq;
            };

            class DataList_out {
            public:
              inline DataList_out(DataList*& _s) : _data(_s) { _data = 0; }
              inline DataList_out(DataList_var& _s)
                : _data(_s._pd_seq) { _s = (DataList*) 0; }
              inline DataList_out(const DataList_out& _s) : _data(_s._data) {}
              inline DataList_out& operator = (const DataList_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline DataList_out& operator = (DataList* _s) {
                _data = _s;
                return *this;
              }
              inline operator DataList*&()  { return _data; }
              inline DataList*& ptr()       { return _data; }
              inline DataList* operator->() { return _data; }

              inline Data& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              DataList*& _data;

            private:
              DataList_out();
              DataList_out& operator=(const DataList_var&);
            };

#ifndef __org_mcfn_mscad_mcore_mcorba_mdb_mDatabase__
#define __org_mcfn_mscad_mcore_mcorba_mdb_mDatabase__

            class Database;
            class _objref_Database;
            class _impl_Database;
            
            typedef _objref_Database* Database_ptr;
            typedef Database_ptr DatabaseRef;

            class Database_Helper {
            public:
              typedef Database_ptr _ptr_type;

              static _ptr_type _nil();
              static _CORBA_Boolean is_nil(_ptr_type);
              static void release(_ptr_type);
              static void duplicate(_ptr_type);
              static void marshalObjRef(_ptr_type, cdrStream&);
              static _ptr_type unmarshalObjRef(cdrStream&);
            };

            typedef _CORBA_ObjRef_Var<_objref_Database, Database_Helper> Database_var;
            typedef _CORBA_ObjRef_OUT_arg<_objref_Database,Database_Helper > Database_out;

#endif

            // interface Database
            class Database {
            public:
              // Declarations for this interface type.
              typedef Database_ptr _ptr_type;
              typedef Database_var _var_type;

              static _ptr_type _duplicate(_ptr_type);
              static _ptr_type _narrow(CORBA::Object_ptr);
              static _ptr_type _unchecked_narrow(CORBA::Object_ptr);
              
              static _ptr_type _nil();

              static inline void _marshalObjRef(_ptr_type, cdrStream&);

              static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
                omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
                if (o)
                  return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
                else
                  return _nil();
              }

              static _core_attr const char* _PD_repoId;

              // Other IDL defined within this scope.
              
            };

            class _objref_Database :
              public virtual CORBA::Object,
              public virtual omniObjRef
            {
            public:
              void putData(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const Data& dt);
              void addHardware(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* hardwareXML);
              void addNode(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* nodeXML);
              DataList* getData(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, CORBA::LongLong event_id, const CORBA::WChar* event_name_id);
              DataList* getDataFromTime(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const util::TimeStamp& tstart, const util::TimeStamp& tend);
              void newEventListAvailable(const hardware::EventList& evtList);
              hardware::NameInfoList* getNodesNames(const util::StringList& nodeUIDs);
              hardware::NameInfoList* getHardwareAndParameterNames(const CORBA::WChar* nodeUID, const util::StringList& hwUIDs);
              void changeName(const hardware::NameInfo& ninfo);
              util::CommentList* getComments(const util::TimeStamp& from, const util::TimeStamp& to);
              util::CommentList* getLastComments(CORBA::Short number);
              void addComment(const util::Comment& newComment);
              void editComment(const util::Comment& toEdit, const util::Comment& toReplace);
              void removeComment(const util::Comment& toRemove);

              inline _objref_Database()  { _PR_setobj(0); }  // nil
              _objref_Database(omniIOR*, omniIdentity*);

            protected:
              virtual ~_objref_Database();

              
            private:
              virtual void* _ptrToObjRef(const char*);

              _objref_Database(const _objref_Database&);
              _objref_Database& operator = (const _objref_Database&);
              // not implemented

              friend class Database;
            };

            class _pof_Database : public _OMNI_NS(proxyObjectFactory) {
            public:
              inline _pof_Database() : _OMNI_NS(proxyObjectFactory)(Database::_PD_repoId) {}
              virtual ~_pof_Database();

              virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
              virtual _CORBA_Boolean is_a(const char*) const;
            };

            class _impl_Database :
              public virtual omniServant
            {
            public:
              virtual ~_impl_Database();

              virtual void putData(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const Data& dt) = 0;
              virtual void addHardware(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* hardwareXML) = 0;
              virtual void addNode(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* nodeXML) = 0;
              virtual DataList* getData(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, CORBA::LongLong event_id, const CORBA::WChar* event_name_id) = 0;
              virtual DataList* getDataFromTime(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const util::TimeStamp& tstart, const util::TimeStamp& tend) = 0;
              virtual void newEventListAvailable(const hardware::EventList& evtList) = 0;
              virtual hardware::NameInfoList* getNodesNames(const util::StringList& nodeUIDs) = 0;
              virtual hardware::NameInfoList* getHardwareAndParameterNames(const CORBA::WChar* nodeUID, const util::StringList& hwUIDs) = 0;
              virtual void changeName(const hardware::NameInfo& ninfo) = 0;
              virtual util::CommentList* getComments(const util::TimeStamp& from, const util::TimeStamp& to) = 0;
              virtual util::CommentList* getLastComments(CORBA::Short number) = 0;
              virtual void addComment(const util::Comment& newComment) = 0;
              virtual void editComment(const util::Comment& toEdit, const util::Comment& toReplace) = 0;
              virtual void removeComment(const util::Comment& toRemove) = 0;
              
            public:  // Really protected, workaround for xlC
              virtual _CORBA_Boolean _dispatch(omniCallHandle&);

            private:
              virtual void* _ptrToInterface(const char*);
              virtual const char* _mostDerivedRepoId();
              
            };


          _CORBA_MODULE_END

          _CORBA_MODULE security

          _CORBA_MODULE_BEG

            enum SecurityError { NOT_AUTHORIZED, AUTHENTICATION_ERROR, ALREADY_REGISTERED, UNKWOWN /*, __max_SecurityError=0xffffffff */ };
            typedef SecurityError& SecurityError_out;

            enum SecurityOperations { HARDWARE_LOCK, DATA_VIEW, CHANGE_NODE_CONN_STATUS, CHANGE_HARDWARE_CONN_STATUS, CHANGE_PARAMETER_CONN_STATUS, EVENT_LOCK, RENAME, CHANGE_HARDWARE_STATUS, MANAGEMENT, KICK_USERS, CONFIGURE, ABORT, ADD_COMMENT, EDIT_COMMENT, REMOVE_COMMENT /*, __max_SecurityOperations=0xffffffff */ };
            typedef SecurityOperations& SecurityOperations_out;

            class SecurityException : public CORBA::UserException {
            public:
              
              SecurityError errorID;

            

              inline SecurityException() {
                pd_insertToAnyFn    = insertToAnyFn;
                pd_insertToAnyFnNCP = insertToAnyFnNCP;
              }
              SecurityException(const SecurityException&);
              SecurityException(SecurityError i_errorID);
              SecurityException& operator=(const SecurityException&);
              virtual ~SecurityException();
              virtual void _raise() const;
              static SecurityException* _downcast(CORBA::Exception*);
              static const SecurityException* _downcast(const CORBA::Exception*);
              static inline SecurityException* _narrow(CORBA::Exception* _e) {
                return _downcast(_e);
              }
              
              void operator>>=(cdrStream&) const ;
              void operator<<=(cdrStream&) ;

              static _core_attr insertExceptionToAny    insertToAnyFn;
              static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

              virtual CORBA::Exception* _NP_duplicate() const;

              static _core_attr const char* _PD_repoId;
              static _core_attr const char* _PD_typeId;

            private:
              virtual const char* _NP_typeId() const;
              virtual const char* _NP_repoId(int*) const;
              virtual void _NP_marshal(cdrStream&) const;
            };

            class ManagementException : public CORBA::UserException {
            public:
              
              CORBA::WString_member error;

            

              inline ManagementException() {
                pd_insertToAnyFn    = insertToAnyFn;
                pd_insertToAnyFnNCP = insertToAnyFnNCP;
              }
              ManagementException(const ManagementException&);
              ManagementException(const CORBA::WChar* i_error);
              ManagementException& operator=(const ManagementException&);
              virtual ~ManagementException();
              virtual void _raise() const;
              static ManagementException* _downcast(CORBA::Exception*);
              static const ManagementException* _downcast(const CORBA::Exception*);
              static inline ManagementException* _narrow(CORBA::Exception* _e) {
                return _downcast(_e);
              }
              
              void operator>>=(cdrStream&) const ;
              void operator<<=(cdrStream&) ;

              static _core_attr insertExceptionToAny    insertToAnyFn;
              static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

              virtual CORBA::Exception* _NP_duplicate() const;

              static _core_attr const char* _PD_repoId;
              static _core_attr const char* _PD_typeId;

            private:
              virtual const char* _NP_typeId() const;
              virtual const char* _NP_repoId(int*) const;
              virtual void _NP_marshal(cdrStream&) const;
            };

          _CORBA_MODULE_END

          _CORBA_MODULE clients

          _CORBA_MODULE_BEG

            enum Profession { UNKNOWN, RESEARCHER, STUDENT, ENGINEER, PROFESSOR, TECHNICIAN, ADMINISTRATIVE, OTHER /*, __max_Profession=0xffffffff */ };
            typedef Profession& Profession_out;

            struct User {
              typedef _CORBA_ConstrType_Variable_Var<User> _var_type;

              
              CORBA::WString_member username;

              util::CharArray password;

              CORBA::Boolean _cxx_operator;

              CORBA::Boolean administrator;

              CORBA::Boolean connectedToChat;

              CORBA::Boolean connectedToVC;

              util::StringList ipaddresses;

              CORBA::WString_member hostname;

              util::StringList groups;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef User::_var_type User_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< User,User_var > User_out;

            struct Institution {
              typedef _CORBA_ConstrType_Variable_Var<Institution> _var_type;

              
              CORBA::WString_member name;

              CORBA::WString_member address;

              CORBA::WString_member phone;

              CORBA::WString_member fax;

              CORBA::WString_member webpage;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef Institution::_var_type Institution_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< Institution,Institution_var > Institution_out;

            struct UserInformations {
              typedef _CORBA_ConstrType_Variable_Var<UserInformations> _var_type;

              
              CORBA::WString_member username;

              CORBA::WString_member name;

              CORBA::WString_member email;

              CORBA::WString_member phone1;

              CORBA::WString_member phone2;

              CORBA::WString_member fax;

              CORBA::WString_member country;

              Profession prof;

              Institution institute;

              util::ByteArray picture;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef UserInformations::_var_type UserInformations_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< UserInformations,UserInformations_var > UserInformations_out;

          _CORBA_MODULE_END

          _CORBA_MODULE hardware

          _CORBA_MODULE_BEG

            enum NodeStatus { NOT_COMMUNICATING, SHUTDOWN, FAULT, RECOVERING, RECONFIGURING, OPERATIONAL, STAND_BY, NRUNNING, TESTING /*, __max_NodeStatus=0xffffffff */ };
            typedef NodeStatus& NodeStatus_out;

            enum HardwareStatus { RUN, RUNNING, STOPPING, STOP, STOPPED, CONFIGURING, CONFIGURE, CONFIGURED, ERROR_STATE, UNKNOWN /*, __max_HardwareStatus=0xffffffff */ };
            typedef HardwareStatus& HardwareStatus_out;

            enum HardwareLockStatus { LOCKED, UNLOCKED /*, __max_HardwareLockStatus=0xffffffff */ };
            typedef HardwareLockStatus& HardwareLockStatus_out;

            enum ConnectionStatus { CONNECTED, DISCONNECTED /*, __max_ConnectionStatus=0xffffffff */ };
            typedef ConnectionStatus& ConnectionStatus_out;

            enum ConfigurationError { NODE_NOT_FOUND, HARDWARE_NOT_FOUND, PARAMETER_NOT_FOUND, FIELD_NOT_FOUND, BAD_VALUE, UNKWOWN /*, __max_ConfigurationError=0xffffffff */ };
            typedef ConfigurationError& ConfigurationError_out;

            class ConfigurationException : public CORBA::UserException {
            public:
              
              ConfigurationError errorID;

            

              inline ConfigurationException() {
                pd_insertToAnyFn    = insertToAnyFn;
                pd_insertToAnyFnNCP = insertToAnyFnNCP;
              }
              ConfigurationException(const ConfigurationException&);
              ConfigurationException(ConfigurationError i_errorID);
              ConfigurationException& operator=(const ConfigurationException&);
              virtual ~ConfigurationException();
              virtual void _raise() const;
              static ConfigurationException* _downcast(CORBA::Exception*);
              static const ConfigurationException* _downcast(const CORBA::Exception*);
              static inline ConfigurationException* _narrow(CORBA::Exception* _e) {
                return _downcast(_e);
              }
              
              void operator>>=(cdrStream&) const ;
              void operator<<=(cdrStream&) ;

              static _core_attr insertExceptionToAny    insertToAnyFn;
              static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

              virtual CORBA::Exception* _NP_duplicate() const;

              static _core_attr const char* _PD_repoId;
              static _core_attr const char* _PD_typeId;

            private:
              virtual const char* _NP_typeId() const;
              virtual const char* _NP_repoId(int*) const;
              virtual void _NP_marshal(cdrStream&) const;
            };

            struct HardwareStatusUID {
              typedef _CORBA_ConstrType_Variable_Var<HardwareStatusUID> _var_type;

              
              CORBA::WString_member uniqueID;

              HardwareStatus stat;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef HardwareStatusUID::_var_type HardwareStatusUID_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< HardwareStatusUID,HardwareStatusUID_var > HardwareStatusUID_out;

            class HardwareStatusList_var;

            class HardwareStatusList : public _CORBA_Unbounded_Sequence< HardwareStatusUID >  {
            public:
              typedef HardwareStatusList_var _var_type;
              inline HardwareStatusList() {}
              inline HardwareStatusList(const HardwareStatusList& _s)
                : _CORBA_Unbounded_Sequence< HardwareStatusUID > (_s) {}

              inline HardwareStatusList(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< HardwareStatusUID > (_max) {}
              inline HardwareStatusList(_CORBA_ULong _max, _CORBA_ULong _len, HardwareStatusUID* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< HardwareStatusUID > (_max, _len, _val, _rel) {}

            

              inline HardwareStatusList& operator = (const HardwareStatusList& _s) {
                _CORBA_Unbounded_Sequence< HardwareStatusUID > ::operator=(_s);
                return *this;
              }
            };

            class HardwareStatusList_out;

            class HardwareStatusList_var {
            public:
              inline HardwareStatusList_var() : _pd_seq(0) {}
              inline HardwareStatusList_var(HardwareStatusList* _s) : _pd_seq(_s) {}
              inline HardwareStatusList_var(const HardwareStatusList_var& _s) {
                if( _s._pd_seq )  _pd_seq = new HardwareStatusList(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~HardwareStatusList_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline HardwareStatusList_var& operator = (HardwareStatusList* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline HardwareStatusList_var& operator = (const HardwareStatusList_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new HardwareStatusList;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline HardwareStatusUID& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline HardwareStatusList* operator -> () { return _pd_seq; }
              inline const HardwareStatusList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator HardwareStatusList& () const { return *_pd_seq; }
#else
              inline operator const HardwareStatusList& () const { return *_pd_seq; }
              inline operator HardwareStatusList& () { return *_pd_seq; }
#endif
                
              inline const HardwareStatusList& in() const { return *_pd_seq; }
              inline HardwareStatusList&       inout()    { return *_pd_seq; }
              inline HardwareStatusList*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline HardwareStatusList* _retn() { HardwareStatusList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class HardwareStatusList_out;
              
            private:
              HardwareStatusList* _pd_seq;
            };

            class HardwareStatusList_out {
            public:
              inline HardwareStatusList_out(HardwareStatusList*& _s) : _data(_s) { _data = 0; }
              inline HardwareStatusList_out(HardwareStatusList_var& _s)
                : _data(_s._pd_seq) { _s = (HardwareStatusList*) 0; }
              inline HardwareStatusList_out(const HardwareStatusList_out& _s) : _data(_s._data) {}
              inline HardwareStatusList_out& operator = (const HardwareStatusList_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline HardwareStatusList_out& operator = (HardwareStatusList* _s) {
                _data = _s;
                return *this;
              }
              inline operator HardwareStatusList*&()  { return _data; }
              inline HardwareStatusList*& ptr()       { return _data; }
              inline HardwareStatusList* operator->() { return _data; }

              inline HardwareStatusUID& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              HardwareStatusList*& _data;

            private:
              HardwareStatusList_out();
              HardwareStatusList_out& operator=(const HardwareStatusList_var&);
            };

            struct TransferFunction {
              typedef _CORBA_ConstrType_Variable_Var<TransferFunction> _var_type;

              
              CORBA::WString_member function;

              CORBA::WString_member units;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef TransferFunction::_var_type TransferFunction_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< TransferFunction,TransferFunction_var > TransferFunction_out;

            struct Connection {
              typedef _CORBA_ConstrType_Variable_Var<Connection> _var_type;

              
              CORBA::WString_member uniqueID;

              ConnectionStatus status;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef Connection::_var_type Connection_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< Connection,Connection_var > Connection_out;

            class ConnectionList_var;

            class ConnectionList : public _CORBA_Unbounded_Sequence< Connection >  {
            public:
              typedef ConnectionList_var _var_type;
              inline ConnectionList() {}
              inline ConnectionList(const ConnectionList& _s)
                : _CORBA_Unbounded_Sequence< Connection > (_s) {}

              inline ConnectionList(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< Connection > (_max) {}
              inline ConnectionList(_CORBA_ULong _max, _CORBA_ULong _len, Connection* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< Connection > (_max, _len, _val, _rel) {}

            

              inline ConnectionList& operator = (const ConnectionList& _s) {
                _CORBA_Unbounded_Sequence< Connection > ::operator=(_s);
                return *this;
              }
            };

            class ConnectionList_out;

            class ConnectionList_var {
            public:
              inline ConnectionList_var() : _pd_seq(0) {}
              inline ConnectionList_var(ConnectionList* _s) : _pd_seq(_s) {}
              inline ConnectionList_var(const ConnectionList_var& _s) {
                if( _s._pd_seq )  _pd_seq = new ConnectionList(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~ConnectionList_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline ConnectionList_var& operator = (ConnectionList* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline ConnectionList_var& operator = (const ConnectionList_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new ConnectionList;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline Connection& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline ConnectionList* operator -> () { return _pd_seq; }
              inline const ConnectionList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator ConnectionList& () const { return *_pd_seq; }
#else
              inline operator const ConnectionList& () const { return *_pd_seq; }
              inline operator ConnectionList& () { return *_pd_seq; }
#endif
                
              inline const ConnectionList& in() const { return *_pd_seq; }
              inline ConnectionList&       inout()    { return *_pd_seq; }
              inline ConnectionList*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline ConnectionList* _retn() { ConnectionList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class ConnectionList_out;
              
            private:
              ConnectionList* _pd_seq;
            };

            class ConnectionList_out {
            public:
              inline ConnectionList_out(ConnectionList*& _s) : _data(_s) { _data = 0; }
              inline ConnectionList_out(ConnectionList_var& _s)
                : _data(_s._pd_seq) { _s = (ConnectionList*) 0; }
              inline ConnectionList_out(const ConnectionList_out& _s) : _data(_s._data) {}
              inline ConnectionList_out& operator = (const ConnectionList_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline ConnectionList_out& operator = (ConnectionList* _s) {
                _data = _s;
                return *this;
              }
              inline operator ConnectionList*&()  { return _data; }
              inline ConnectionList*& ptr()       { return _data; }
              inline ConnectionList* operator->() { return _data; }

              inline Connection& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              ConnectionList*& _data;

            private:
              ConnectionList_out();
              ConnectionList_out& operator=(const ConnectionList_var&);
            };

            struct FieldData {
              typedef _CORBA_ConstrType_Variable_Var<FieldData> _var_type;

              
              CORBA::WString_member fieldUniqueID;

              util::ByteArray value;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef FieldData::_var_type FieldData_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< FieldData,FieldData_var > FieldData_out;

            class FieldDataList_var;

            class FieldDataList : public _CORBA_Unbounded_Sequence< FieldData >  {
            public:
              typedef FieldDataList_var _var_type;
              inline FieldDataList() {}
              inline FieldDataList(const FieldDataList& _s)
                : _CORBA_Unbounded_Sequence< FieldData > (_s) {}

              inline FieldDataList(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< FieldData > (_max) {}
              inline FieldDataList(_CORBA_ULong _max, _CORBA_ULong _len, FieldData* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< FieldData > (_max, _len, _val, _rel) {}

            

              inline FieldDataList& operator = (const FieldDataList& _s) {
                _CORBA_Unbounded_Sequence< FieldData > ::operator=(_s);
                return *this;
              }
            };

            class FieldDataList_out;

            class FieldDataList_var {
            public:
              inline FieldDataList_var() : _pd_seq(0) {}
              inline FieldDataList_var(FieldDataList* _s) : _pd_seq(_s) {}
              inline FieldDataList_var(const FieldDataList_var& _s) {
                if( _s._pd_seq )  _pd_seq = new FieldDataList(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~FieldDataList_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline FieldDataList_var& operator = (FieldDataList* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline FieldDataList_var& operator = (const FieldDataList_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new FieldDataList;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline FieldData& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline FieldDataList* operator -> () { return _pd_seq; }
              inline const FieldDataList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator FieldDataList& () const { return *_pd_seq; }
#else
              inline operator const FieldDataList& () const { return *_pd_seq; }
              inline operator FieldDataList& () { return *_pd_seq; }
#endif
                
              inline const FieldDataList& in() const { return *_pd_seq; }
              inline FieldDataList&       inout()    { return *_pd_seq; }
              inline FieldDataList*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline FieldDataList* _retn() { FieldDataList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class FieldDataList_out;
              
            private:
              FieldDataList* _pd_seq;
            };

            class FieldDataList_out {
            public:
              inline FieldDataList_out(FieldDataList*& _s) : _data(_s) { _data = 0; }
              inline FieldDataList_out(FieldDataList_var& _s)
                : _data(_s._pd_seq) { _s = (FieldDataList*) 0; }
              inline FieldDataList_out(const FieldDataList_out& _s) : _data(_s._data) {}
              inline FieldDataList_out& operator = (const FieldDataList_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline FieldDataList_out& operator = (FieldDataList* _s) {
                _data = _s;
                return *this;
              }
              inline operator FieldDataList*&()  { return _data; }
              inline FieldDataList*& ptr()       { return _data; }
              inline FieldDataList* operator->() { return _data; }

              inline FieldData& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              FieldDataList*& _data;

            private:
              FieldDataList_out();
              FieldDataList_out& operator=(const FieldDataList_var&);
            };

            struct HardwareLock {
              typedef _CORBA_ConstrType_Variable_Var<HardwareLock> _var_type;

              
              CORBA::WString_member nodeUniqueID;

              CORBA::WString_member hardwareUniqueID;

              clients::User owner;

              HardwareLockStatus status;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef HardwareLock::_var_type HardwareLock_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< HardwareLock,HardwareLock_var > HardwareLock_out;

            class HardwareLockList_var;

            class HardwareLockList : public _CORBA_Unbounded_Sequence< HardwareLock >  {
            public:
              typedef HardwareLockList_var _var_type;
              inline HardwareLockList() {}
              inline HardwareLockList(const HardwareLockList& _s)
                : _CORBA_Unbounded_Sequence< HardwareLock > (_s) {}

              inline HardwareLockList(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< HardwareLock > (_max) {}
              inline HardwareLockList(_CORBA_ULong _max, _CORBA_ULong _len, HardwareLock* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< HardwareLock > (_max, _len, _val, _rel) {}

            

              inline HardwareLockList& operator = (const HardwareLockList& _s) {
                _CORBA_Unbounded_Sequence< HardwareLock > ::operator=(_s);
                return *this;
              }
            };

            class HardwareLockList_out;

            class HardwareLockList_var {
            public:
              inline HardwareLockList_var() : _pd_seq(0) {}
              inline HardwareLockList_var(HardwareLockList* _s) : _pd_seq(_s) {}
              inline HardwareLockList_var(const HardwareLockList_var& _s) {
                if( _s._pd_seq )  _pd_seq = new HardwareLockList(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~HardwareLockList_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline HardwareLockList_var& operator = (HardwareLockList* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline HardwareLockList_var& operator = (const HardwareLockList_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new HardwareLockList;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline HardwareLock& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline HardwareLockList* operator -> () { return _pd_seq; }
              inline const HardwareLockList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator HardwareLockList& () const { return *_pd_seq; }
#else
              inline operator const HardwareLockList& () const { return *_pd_seq; }
              inline operator HardwareLockList& () { return *_pd_seq; }
#endif
                
              inline const HardwareLockList& in() const { return *_pd_seq; }
              inline HardwareLockList&       inout()    { return *_pd_seq; }
              inline HardwareLockList*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline HardwareLockList* _retn() { HardwareLockList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class HardwareLockList_out;
              
            private:
              HardwareLockList* _pd_seq;
            };

            class HardwareLockList_out {
            public:
              inline HardwareLockList_out(HardwareLockList*& _s) : _data(_s) { _data = 0; }
              inline HardwareLockList_out(HardwareLockList_var& _s)
                : _data(_s._pd_seq) { _s = (HardwareLockList*) 0; }
              inline HardwareLockList_out(const HardwareLockList_out& _s) : _data(_s._data) {}
              inline HardwareLockList_out& operator = (const HardwareLockList_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline HardwareLockList_out& operator = (HardwareLockList* _s) {
                _data = _s;
                return *this;
              }
              inline operator HardwareLockList*&()  { return _data; }
              inline HardwareLockList*& ptr()       { return _data; }
              inline HardwareLockList* operator->() { return _data; }

              inline HardwareLock& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              HardwareLockList*& _data;

            private:
              HardwareLockList_out();
              HardwareLockList_out& operator=(const HardwareLockList_var&);
            };

            struct ExtraLib {
              typedef _CORBA_ConstrType_Variable_Var<ExtraLib> _var_type;

              
              util::TimeStamp lastModified;

              util::ByteArray jarFile;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef ExtraLib::_var_type ExtraLib_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< ExtraLib,ExtraLib_var > ExtraLib_out;

#ifndef __org_mcfn_mscad_mcore_mcorba_mhardware_mNode__
#define __org_mcfn_mscad_mcore_mcorba_mhardware_mNode__

            class Node;
            class _objref_Node;
            class _impl_Node;
            
            typedef _objref_Node* Node_ptr;
            typedef Node_ptr NodeRef;

            class Node_Helper {
            public:
              typedef Node_ptr _ptr_type;

              static _ptr_type _nil();
              static _CORBA_Boolean is_nil(_ptr_type);
              static void release(_ptr_type);
              static void duplicate(_ptr_type);
              static void marshalObjRef(_ptr_type, cdrStream&);
              static _ptr_type unmarshalObjRef(cdrStream&);
            };

            typedef _CORBA_ObjRef_Var<_objref_Node, Node_Helper> Node_var;
            typedef _CORBA_ObjRef_OUT_arg<_objref_Node,Node_Helper > Node_out;

#endif

            // interface Node
            class Node {
            public:
              // Declarations for this interface type.
              typedef Node_ptr _ptr_type;
              typedef Node_var _var_type;

              static _ptr_type _duplicate(_ptr_type);
              static _ptr_type _narrow(CORBA::Object_ptr);
              static _ptr_type _unchecked_narrow(CORBA::Object_ptr);
              
              static _ptr_type _nil();

              static inline void _marshalObjRef(_ptr_type, cdrStream&);

              static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
                omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
                if (o)
                  return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
                else
                  return _nil();
              }

              static _core_attr const char* _PD_repoId;

              // Other IDL defined within this scope.
              
            };

            class _objref_Node :
              public virtual CORBA::Object,
              public virtual omniObjRef
            {
            public:
              CORBA::WChar* getNodeInfo();
              util::StringList* getHardwareInfos();
              void ping();
              FieldData* getParameterValue(const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const CORBA::WChar* fieldUniqueID);
              FieldDataList* getParameterValues(const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID);
              void configure(const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const FieldDataList& data);
              void shutdown(const CORBA::WChar* reason);
              ExtraLib* getExtraLibs(const util::TimeStamp& lastDownload);
              ConnectionStatus getConnectionStatus();
              void changeConnectionStatus(ConnectionStatus newStatus);
              ConnectionStatus getHardwareConnectionStatus(const CORBA::WChar* hardwareUniqueID);
              ConnectionList* getAllHardwareConnectionStatus();
              void changeHardwareConnectionStatus(const CORBA::WChar* hardwareUniqueID, ConnectionStatus newStatus);
              ConnectionList* getAllParametersConnectionStatus(const CORBA::WChar* hardwareUniqueID);
              ConnectionStatus getParameterConnectionStatus(const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID);
              void changeParameterConnectionStatus(const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, ConnectionStatus newStatus);
              NodeStatus getNodeStatus();
              HardwareStatus getHardwareStatus(const CORBA::WChar* hardwareUniqueID);
              HardwareStatusList* getAllHardwareStatus();
              void changeHardwareStatus(const CORBA::WChar* hardwareUniqueID, HardwareStatus newStatus);
              void changeAllHardwareStatus(HardwareStatus newStatus);
              void setEventTable(const EventList& evtList);
              TransferFunction* getTransferFunction(const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID);
              void setTransferFunction(const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const TransferFunction& tf);
              void newDataAvailable(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const EventList& eList, const util::TimeStamp& tstart, const util::TimeStamp& tend);
              void abort();

              inline _objref_Node()  { _PR_setobj(0); }  // nil
              _objref_Node(omniIOR*, omniIdentity*);

            protected:
              virtual ~_objref_Node();

              
            private:
              virtual void* _ptrToObjRef(const char*);

              _objref_Node(const _objref_Node&);
              _objref_Node& operator = (const _objref_Node&);
              // not implemented

              friend class Node;
            };

            class _pof_Node : public _OMNI_NS(proxyObjectFactory) {
            public:
              inline _pof_Node() : _OMNI_NS(proxyObjectFactory)(Node::_PD_repoId) {}
              virtual ~_pof_Node();

              virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
              virtual _CORBA_Boolean is_a(const char*) const;
            };

            class _impl_Node :
              public virtual omniServant
            {
            public:
              virtual ~_impl_Node();

              virtual CORBA::WChar* getNodeInfo() = 0;
              virtual util::StringList* getHardwareInfos() = 0;
              virtual void ping() = 0;
              virtual FieldData* getParameterValue(const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const CORBA::WChar* fieldUniqueID) = 0;
              virtual FieldDataList* getParameterValues(const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID) = 0;
              virtual void configure(const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const FieldDataList& data) = 0;
              virtual void shutdown(const CORBA::WChar* reason) = 0;
              virtual ExtraLib* getExtraLibs(const util::TimeStamp& lastDownload) = 0;
              virtual ConnectionStatus getConnectionStatus() = 0;
              virtual void changeConnectionStatus(ConnectionStatus newStatus) = 0;
              virtual ConnectionStatus getHardwareConnectionStatus(const CORBA::WChar* hardwareUniqueID) = 0;
              virtual ConnectionList* getAllHardwareConnectionStatus() = 0;
              virtual void changeHardwareConnectionStatus(const CORBA::WChar* hardwareUniqueID, ConnectionStatus newStatus) = 0;
              virtual ConnectionList* getAllParametersConnectionStatus(const CORBA::WChar* hardwareUniqueID) = 0;
              virtual ConnectionStatus getParameterConnectionStatus(const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID) = 0;
              virtual void changeParameterConnectionStatus(const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, ConnectionStatus newStatus) = 0;
              virtual NodeStatus getNodeStatus() = 0;
              virtual HardwareStatus getHardwareStatus(const CORBA::WChar* hardwareUniqueID) = 0;
              virtual HardwareStatusList* getAllHardwareStatus() = 0;
              virtual void changeHardwareStatus(const CORBA::WChar* hardwareUniqueID, HardwareStatus newStatus) = 0;
              virtual void changeAllHardwareStatus(HardwareStatus newStatus) = 0;
              virtual void setEventTable(const EventList& evtList) = 0;
              virtual TransferFunction* getTransferFunction(const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID) = 0;
              virtual void setTransferFunction(const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const TransferFunction& tf) = 0;
              virtual void newDataAvailable(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const EventList& eList, const util::TimeStamp& tstart, const util::TimeStamp& tend) = 0;
              virtual void abort() = 0;
              
            public:  // Really protected, workaround for xlC
              virtual _CORBA_Boolean _dispatch(omniCallHandle&);

            private:
              virtual void* _ptrToInterface(const char*);
              virtual const char* _mostDerivedRepoId();
              
            };


          _CORBA_MODULE_END

          _CORBA_MODULE clients

          _CORBA_MODULE_BEG

            class UserList_var;

            class UserList : public _CORBA_Unbounded_Sequence< User >  {
            public:
              typedef UserList_var _var_type;
              inline UserList() {}
              inline UserList(const UserList& _s)
                : _CORBA_Unbounded_Sequence< User > (_s) {}

              inline UserList(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< User > (_max) {}
              inline UserList(_CORBA_ULong _max, _CORBA_ULong _len, User* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< User > (_max, _len, _val, _rel) {}

            

              inline UserList& operator = (const UserList& _s) {
                _CORBA_Unbounded_Sequence< User > ::operator=(_s);
                return *this;
              }
            };

            class UserList_out;

            class UserList_var {
            public:
              inline UserList_var() : _pd_seq(0) {}
              inline UserList_var(UserList* _s) : _pd_seq(_s) {}
              inline UserList_var(const UserList_var& _s) {
                if( _s._pd_seq )  _pd_seq = new UserList(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~UserList_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline UserList_var& operator = (UserList* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline UserList_var& operator = (const UserList_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new UserList;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline User& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline UserList* operator -> () { return _pd_seq; }
              inline const UserList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator UserList& () const { return *_pd_seq; }
#else
              inline operator const UserList& () const { return *_pd_seq; }
              inline operator UserList& () { return *_pd_seq; }
#endif
                
              inline const UserList& in() const { return *_pd_seq; }
              inline UserList&       inout()    { return *_pd_seq; }
              inline UserList*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline UserList* _retn() { UserList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class UserList_out;
              
            private:
              UserList* _pd_seq;
            };

            class UserList_out {
            public:
              inline UserList_out(UserList*& _s) : _data(_s) { _data = 0; }
              inline UserList_out(UserList_var& _s)
                : _data(_s._pd_seq) { _s = (UserList*) 0; }
              inline UserList_out(const UserList_out& _s) : _data(_s._data) {}
              inline UserList_out& operator = (const UserList_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline UserList_out& operator = (UserList* _s) {
                _data = _s;
                return *this;
              }
              inline operator UserList*&()  { return _data; }
              inline UserList*& ptr()       { return _data; }
              inline UserList* operator->() { return _data; }

              inline User& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              UserList*& _data;

            private:
              UserList_out();
              UserList_out& operator=(const UserList_var&);
            };

            struct ProfileElement {
              typedef _CORBA_ConstrType_Variable_Var<ProfileElement> _var_type;

              
              CORBA::WString_member nodeUniqueID;

              CORBA::WString_member hardwareUniqueID;

              CORBA::WString_member parameterUniqueID;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef ProfileElement::_var_type ProfileElement_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< ProfileElement,ProfileElement_var > ProfileElement_out;

            class ProfileElementList_var;

            class ProfileElementList : public _CORBA_Unbounded_Sequence< ProfileElement >  {
            public:
              typedef ProfileElementList_var _var_type;
              inline ProfileElementList() {}
              inline ProfileElementList(const ProfileElementList& _s)
                : _CORBA_Unbounded_Sequence< ProfileElement > (_s) {}

              inline ProfileElementList(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< ProfileElement > (_max) {}
              inline ProfileElementList(_CORBA_ULong _max, _CORBA_ULong _len, ProfileElement* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< ProfileElement > (_max, _len, _val, _rel) {}

            

              inline ProfileElementList& operator = (const ProfileElementList& _s) {
                _CORBA_Unbounded_Sequence< ProfileElement > ::operator=(_s);
                return *this;
              }
            };

            class ProfileElementList_out;

            class ProfileElementList_var {
            public:
              inline ProfileElementList_var() : _pd_seq(0) {}
              inline ProfileElementList_var(ProfileElementList* _s) : _pd_seq(_s) {}
              inline ProfileElementList_var(const ProfileElementList_var& _s) {
                if( _s._pd_seq )  _pd_seq = new ProfileElementList(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~ProfileElementList_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline ProfileElementList_var& operator = (ProfileElementList* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline ProfileElementList_var& operator = (const ProfileElementList_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new ProfileElementList;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline ProfileElement& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline ProfileElementList* operator -> () { return _pd_seq; }
              inline const ProfileElementList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator ProfileElementList& () const { return *_pd_seq; }
#else
              inline operator const ProfileElementList& () const { return *_pd_seq; }
              inline operator ProfileElementList& () { return *_pd_seq; }
#endif
                
              inline const ProfileElementList& in() const { return *_pd_seq; }
              inline ProfileElementList&       inout()    { return *_pd_seq; }
              inline ProfileElementList*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline ProfileElementList* _retn() { ProfileElementList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class ProfileElementList_out;
              
            private:
              ProfileElementList* _pd_seq;
            };

            class ProfileElementList_out {
            public:
              inline ProfileElementList_out(ProfileElementList*& _s) : _data(_s) { _data = 0; }
              inline ProfileElementList_out(ProfileElementList_var& _s)
                : _data(_s._pd_seq) { _s = (ProfileElementList*) 0; }
              inline ProfileElementList_out(const ProfileElementList_out& _s) : _data(_s._data) {}
              inline ProfileElementList_out& operator = (const ProfileElementList_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline ProfileElementList_out& operator = (ProfileElementList* _s) {
                _data = _s;
                return *this;
              }
              inline operator ProfileElementList*&()  { return _data; }
              inline ProfileElementList*& ptr()       { return _data; }
              inline ProfileElementList* operator->() { return _data; }

              inline ProfileElement& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              ProfileElementList*& _data;

            private:
              ProfileElementList_out();
              ProfileElementList_out& operator=(const ProfileElementList_var&);
            };

            struct Profile {
              typedef _CORBA_ConstrType_Variable_Var<Profile> _var_type;

              
              CORBA::WString_member owner;

              CORBA::WString_member name;

              ProfileElementList elements;

              CORBA::Boolean public_access;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef Profile::_var_type Profile_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< Profile,Profile_var > Profile_out;

            class ProfileList_var;

            class ProfileList : public _CORBA_Unbounded_Sequence< Profile >  {
            public:
              typedef ProfileList_var _var_type;
              inline ProfileList() {}
              inline ProfileList(const ProfileList& _s)
                : _CORBA_Unbounded_Sequence< Profile > (_s) {}

              inline ProfileList(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< Profile > (_max) {}
              inline ProfileList(_CORBA_ULong _max, _CORBA_ULong _len, Profile* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< Profile > (_max, _len, _val, _rel) {}

            

              inline ProfileList& operator = (const ProfileList& _s) {
                _CORBA_Unbounded_Sequence< Profile > ::operator=(_s);
                return *this;
              }
            };

            class ProfileList_out;

            class ProfileList_var {
            public:
              inline ProfileList_var() : _pd_seq(0) {}
              inline ProfileList_var(ProfileList* _s) : _pd_seq(_s) {}
              inline ProfileList_var(const ProfileList_var& _s) {
                if( _s._pd_seq )  _pd_seq = new ProfileList(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~ProfileList_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline ProfileList_var& operator = (ProfileList* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline ProfileList_var& operator = (const ProfileList_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new ProfileList;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline Profile& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline ProfileList* operator -> () { return _pd_seq; }
              inline const ProfileList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator ProfileList& () const { return *_pd_seq; }
#else
              inline operator const ProfileList& () const { return *_pd_seq; }
              inline operator ProfileList& () { return *_pd_seq; }
#endif
                
              inline const ProfileList& in() const { return *_pd_seq; }
              inline ProfileList&       inout()    { return *_pd_seq; }
              inline ProfileList*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline ProfileList* _retn() { ProfileList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class ProfileList_out;
              
            private:
              ProfileList* _pd_seq;
            };

            class ProfileList_out {
            public:
              inline ProfileList_out(ProfileList*& _s) : _data(_s) { _data = 0; }
              inline ProfileList_out(ProfileList_var& _s)
                : _data(_s._pd_seq) { _s = (ProfileList*) 0; }
              inline ProfileList_out(const ProfileList_out& _s) : _data(_s._data) {}
              inline ProfileList_out& operator = (const ProfileList_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline ProfileList_out& operator = (ProfileList* _s) {
                _data = _s;
                return *this;
              }
              inline operator ProfileList*&()  { return _data; }
              inline ProfileList*& ptr()       { return _data; }
              inline ProfileList* operator->() { return _data; }

              inline Profile& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              ProfileList*& _data;

            private:
              ProfileList_out();
              ProfileList_out& operator=(const ProfileList_var&);
            };

#ifndef __org_mcfn_mscad_mcore_mcorba_mclients_mClient__
#define __org_mcfn_mscad_mcore_mcorba_mclients_mClient__

            class Client;
            class _objref_Client;
            class _impl_Client;
            
            typedef _objref_Client* Client_ptr;
            typedef Client_ptr ClientRef;

            class Client_Helper {
            public:
              typedef Client_ptr _ptr_type;

              static _ptr_type _nil();
              static _CORBA_Boolean is_nil(_ptr_type);
              static void release(_ptr_type);
              static void duplicate(_ptr_type);
              static void marshalObjRef(_ptr_type, cdrStream&);
              static _ptr_type unmarshalObjRef(cdrStream&);
            };

            typedef _CORBA_ObjRef_Var<_objref_Client, Client_Helper> Client_var;
            typedef _CORBA_ObjRef_OUT_arg<_objref_Client,Client_Helper > Client_out;

#endif

            // interface Client
            class Client {
            public:
              // Declarations for this interface type.
              typedef Client_ptr _ptr_type;
              typedef Client_var _var_type;

              static _ptr_type _duplicate(_ptr_type);
              static _ptr_type _narrow(CORBA::Object_ptr);
              static _ptr_type _unchecked_narrow(CORBA::Object_ptr);
              
              static _ptr_type _nil();

              static inline void _marshalObjRef(_ptr_type, cdrStream&);

              static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
                omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
                if (o)
                  return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
                else
                  return _nil();
              }

              static _core_attr const char* _PD_repoId;

              // Other IDL defined within this scope.
              
            };

            class _objref_Client :
              public virtual CORBA::Object,
              public virtual omniObjRef
            {
            public:
              void ping();
              User* getUser();
              void setUser(const User& usr);
              void usersListChanged();
              void nodeListChanged();
              void hardwareLockStatusChanged();
              void eventEditLockStatusChanged();
              void requireLock(const User& usr, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* reason);
              void newMessage(const CORBA::WChar* message);
              void connectionStatusChanged(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID);
              void hardwareStatusChange(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, hardware::HardwareStatus newStatus);
              void nodeStatusChange(const CORBA::WChar* nodeUniqueID, hardware::NodeStatus newStatus);
              void hardwareListChanged(const CORBA::WChar* nodeUniqueID);
              void newDataAvailable(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const hardware::EventList& eList, const util::TimeStamp& tstart, const util::TimeStamp& tend);
              void newPluginXMLAvailable();
              void userPropertyChanged(const CORBA::WChar* username, const CORBA::WChar* propName, CORBA::Boolean propValue);
              void shareData(const CORBA::WChar* userFrom, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const CORBA::WChar* pluginclasslocin, const util::TimeStamp& tstart, const util::TimeStamp& tend);
              void nameChanged(const hardware::NameInfo& ninfo);
              void newEventListAvailable(const hardware::EventList& evtList);
              void kick(const CORBA::WChar* adminUsername, const CORBA::WChar* reason);
              void commentAdded(const util::Comment& c);
              void commentEdited(const util::Comment& oldComment, const util::Comment& newComment);
              void commentRemoved(const util::Comment& c);

              inline _objref_Client()  { _PR_setobj(0); }  // nil
              _objref_Client(omniIOR*, omniIdentity*);

            protected:
              virtual ~_objref_Client();

              
            private:
              virtual void* _ptrToObjRef(const char*);

              _objref_Client(const _objref_Client&);
              _objref_Client& operator = (const _objref_Client&);
              // not implemented

              friend class Client;
            };

            class _pof_Client : public _OMNI_NS(proxyObjectFactory) {
            public:
              inline _pof_Client() : _OMNI_NS(proxyObjectFactory)(Client::_PD_repoId) {}
              virtual ~_pof_Client();

              virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
              virtual _CORBA_Boolean is_a(const char*) const;
            };

            class _impl_Client :
              public virtual omniServant
            {
            public:
              virtual ~_impl_Client();

              virtual void ping() = 0;
              virtual User* getUser() = 0;
              virtual void setUser(const User& usr) = 0;
              virtual void usersListChanged() = 0;
              virtual void nodeListChanged() = 0;
              virtual void hardwareLockStatusChanged() = 0;
              virtual void eventEditLockStatusChanged() = 0;
              virtual void requireLock(const User& usr, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* reason) = 0;
              virtual void newMessage(const CORBA::WChar* message) = 0;
              virtual void connectionStatusChanged(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID) = 0;
              virtual void hardwareStatusChange(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, hardware::HardwareStatus newStatus) = 0;
              virtual void nodeStatusChange(const CORBA::WChar* nodeUniqueID, hardware::NodeStatus newStatus) = 0;
              virtual void hardwareListChanged(const CORBA::WChar* nodeUniqueID) = 0;
              virtual void newDataAvailable(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const hardware::EventList& eList, const util::TimeStamp& tstart, const util::TimeStamp& tend) = 0;
              virtual void newPluginXMLAvailable() = 0;
              virtual void userPropertyChanged(const CORBA::WChar* username, const CORBA::WChar* propName, CORBA::Boolean propValue) = 0;
              virtual void shareData(const CORBA::WChar* userFrom, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const CORBA::WChar* pluginclasslocin, const util::TimeStamp& tstart, const util::TimeStamp& tend) = 0;
              virtual void nameChanged(const hardware::NameInfo& ninfo) = 0;
              virtual void newEventListAvailable(const hardware::EventList& evtList) = 0;
              virtual void kick(const CORBA::WChar* adminUsername, const CORBA::WChar* reason) = 0;
              virtual void commentAdded(const util::Comment& c) = 0;
              virtual void commentEdited(const util::Comment& oldComment, const util::Comment& newComment) = 0;
              virtual void commentRemoved(const util::Comment& c) = 0;
              
            public:  // Really protected, workaround for xlC
              virtual _CORBA_Boolean _dispatch(omniCallHandle&);

            private:
              virtual void* _ptrToInterface(const char*);
              virtual const char* _mostDerivedRepoId();
              
            };


          _CORBA_MODULE_END

          _CORBA_MODULE server

          _CORBA_MODULE_BEG

#ifndef __org_mcfn_mscad_mcore_mcorba_mserver_mCentralServer__
#define __org_mcfn_mscad_mcore_mcorba_mserver_mCentralServer__

            class CentralServer;
            class _objref_CentralServer;
            class _impl_CentralServer;
            
            typedef _objref_CentralServer* CentralServer_ptr;
            typedef CentralServer_ptr CentralServerRef;

            class CentralServer_Helper {
            public:
              typedef CentralServer_ptr _ptr_type;

              static _ptr_type _nil();
              static _CORBA_Boolean is_nil(_ptr_type);
              static void release(_ptr_type);
              static void duplicate(_ptr_type);
              static void marshalObjRef(_ptr_type, cdrStream&);
              static _ptr_type unmarshalObjRef(cdrStream&);
            };

            typedef _CORBA_ObjRef_Var<_objref_CentralServer, CentralServer_Helper> CentralServer_var;
            typedef _CORBA_ObjRef_OUT_arg<_objref_CentralServer,CentralServer_Helper > CentralServer_out;

#endif

            // interface CentralServer
            class CentralServer {
            public:
              // Declarations for this interface type.
              typedef CentralServer_ptr _ptr_type;
              typedef CentralServer_var _var_type;

              static _ptr_type _duplicate(_ptr_type);
              static _ptr_type _narrow(CORBA::Object_ptr);
              static _ptr_type _unchecked_narrow(CORBA::Object_ptr);
              
              static _ptr_type _nil();

              static inline void _marshalObjRef(_ptr_type, cdrStream&);

              static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
                omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
                if (o)
                  return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
                else
                  return _nil();
              }

              static _core_attr const char* _PD_repoId;

              // Other IDL defined within this scope.
              
            };

            class _objref_CentralServer :
              public virtual CORBA::Object,
              public virtual omniObjRef
            {
            public:
              hardware::HardwareLockList* getHardwareLockStatus();
              util::StringList* getNodes();
              util::StringList* getHardwareInfos(const CORBA::WChar* nodeUniqueID);
              void requireLock(const clients::User& user, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* reason);
              void changeHardwareStatus(const clients::User& user, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, hardware::HardwareStatus newStatus);
              void changeAllHardwareStatus(const clients::User& user, const CORBA::WChar* nodeUniqueID, hardware::HardwareStatus newStatus);
              hardware::FieldData* getParameterValue(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const CORBA::WChar* fieldUniqueID);
              hardware::FieldDataList* getParameterValues(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID);
              hardware::ExtraLib* getExtraLibs(const CORBA::WChar* nodeUniqueID, const util::TimeStamp& lastDownload);
              void configure(const clients::User& usr, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const hardware::FieldDataList& data);
              hardware::ConnectionStatus getNodeConnectionStatus(const CORBA::WChar* nodeUniqueID);
              void changeNodeConnectionStatus(const clients::User& usr, const CORBA::WChar* nodeUniqueID, hardware::ConnectionStatus newStatus);
              hardware::ConnectionList* getAllHardwareConnectionStatus(const CORBA::WChar* nodeUniqueID);
              hardware::ConnectionStatus getHardwareConnectionStatus(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID);
              void changeHardwareConnectionStatus(const clients::User& usr, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, hardware::ConnectionStatus newStatus);
              hardware::ConnectionList* getAllParametersConnectionStatus(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID);
              hardware::ConnectionStatus getParameterConnectionStatus(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID);
              void changeParameterConnectionStatus(const clients::User& usr, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, hardware::ConnectionStatus newStatus);
              hardware::TransferFunction* getTransferFunction(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID);
              void setTransferFunction(const clients::User& usr, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const hardware::TransferFunction& tf);
              void connectionStatusChanged(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID);
              CORBA::Boolean isUserAllowed(const clients::User& usr, security::SecurityOperations oper, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID);
              clients::UserList* getConnectedUsers();
              CORBA::Boolean lock(const clients::User& usr, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID);
              CORBA::Boolean unlock(const clients::User& usr, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID);
              void eventEditLock(const clients::User& usr);
              void eventEditUnLock(const clients::User& usr);
              void hardwareListChanged(const CORBA::WChar* nodeUniqueID);
              CORBA::Boolean isEventEditLocked();
              CORBA::WChar* getXMLEvents();
              hardware::EventList* getLastEventTable();
              void setEventTable(const clients::User& usr, const hardware::EventList& evtList);
              void fireEventTable(const CORBA::WChar* nodeUniqueID, const hardware::EventList& evtList);
              void newEventListAdded(const hardware::EventList& evtList);
              void abort(const clients::User& usr);
              void hardwareStatusChange(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, hardware::HardwareStatus newStatus);
              void nodeStatusChange(const CORBA::WChar* nodeUniqueID, hardware::NodeStatus newStatus);
              hardware::NodeStatus getNodeStatus(const CORBA::WChar* nodeUniqueID);
              hardware::HardwareStatusList* getAllHardwareStatus(const CORBA::WChar* nodeUniqueID);
              util::TimeStamp getCurrentTime();
              void newDataAvailable(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const db::Data& data);
              void newDataStored(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const hardware::EventList& eList, const util::TimeStamp& tstart, const util::TimeStamp& tend);
              db::DataList* getData(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, CORBA::LongLong event_id, const CORBA::WChar* event_name_id);
              db::DataList* getDataFromTime(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const util::TimeStamp& tstart, const util::TimeStamp& tend);
              CORBA::WChar* getPluginsXML();
              clients::ProfileList* getAllPublicProfiles();
              clients::ProfileList* getAllUserProfiles(const clients::User& usr);
              void saveProfile(const clients::User& usr, const clients::Profile& prof);
              void deleteProfile(const clients::User& usr, const clients::Profile& prof);
              void userPropertyChanged(const CORBA::WChar* username, const CORBA::WChar* propName, CORBA::Boolean propValue);
              void shareData(const CORBA::WChar* userFrom, const util::StringList& usersTo, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const CORBA::WChar* pluginclassloc, const util::TimeStamp& tstart, const util::TimeStamp& tend);
              void kickUser(const clients::User& administrator, const CORBA::WChar* userToKick, const CORBA::WChar* reason);
              void ping();
              hardware::NameInfoList* getNodesNames(const util::StringList& nodeUIDs);
              hardware::NameInfoList* getHardwareAndParameterNames(const CORBA::WChar* nodeUID, const util::StringList& hwUIDs);
              void changeName(const clients::User& usr, const hardware::NameInfo& ninfo);
              void nameChanged(const hardware::NameInfo& ninfo);
              void addUser(const clients::User& administrator, const clients::User& usr, const clients::UserInformations& usrInfo);
              void removeUser(const clients::User& administrator, const CORBA::WChar* username);
              void editUser(const clients::User& administrator, const clients::User& usr);
              void editUserInformations(const clients::User& administrator, const clients::UserInformations& usrInfos);
              clients::UserInformations* getUserInformations(const CORBA::WChar* username);
              util::StringList* getAllUsers();
              clients::User* getUser(const clients::User& administrator, const CORBA::WChar* username);
              void changePassword(const clients::User& user, const util::CharArray& password);
              void addInstitution(const clients::User& administrator, const clients::Institution& institute);
              void removeInstitution(const clients::User& administrator, const CORBA::WChar* name);
              void editInstitution(const clients::User& administrator, const clients::Institution& institute);
              util::StringList* getAllInstitutions();
              clients::Institution* getInstitution(const CORBA::WChar* name);
              CORBA::WChar* getGroupsXML();
              void updateGroupsXML(const clients::User& administrator, const CORBA::WChar* xml);
              util::CommentList* getComments(const util::TimeStamp& from, const util::TimeStamp& to);
              util::CommentList* getLastComments(CORBA::Short number);
              void addComment(const util::Comment& newComment);
              void editComment(const util::Comment& toEdit, const util::Comment& toReplace);
              void removeComment(const util::Comment& toRemove);
              void commentAdded(const util::Comment& newComment);
              void commentEdited(const util::Comment& toEdit, const util::Comment& toReplace);
              void commentRemoved(const util::Comment& toRemove);

              inline _objref_CentralServer()  { _PR_setobj(0); }  // nil
              _objref_CentralServer(omniIOR*, omniIdentity*);

            protected:
              virtual ~_objref_CentralServer();

              
            private:
              virtual void* _ptrToObjRef(const char*);

              _objref_CentralServer(const _objref_CentralServer&);
              _objref_CentralServer& operator = (const _objref_CentralServer&);
              // not implemented

              friend class CentralServer;
            };

            class _pof_CentralServer : public _OMNI_NS(proxyObjectFactory) {
            public:
              inline _pof_CentralServer() : _OMNI_NS(proxyObjectFactory)(CentralServer::_PD_repoId) {}
              virtual ~_pof_CentralServer();

              virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
              virtual _CORBA_Boolean is_a(const char*) const;
            };

            class _impl_CentralServer :
              public virtual omniServant
            {
            public:
              virtual ~_impl_CentralServer();

              virtual hardware::HardwareLockList* getHardwareLockStatus() = 0;
              virtual util::StringList* getNodes() = 0;
              virtual util::StringList* getHardwareInfos(const CORBA::WChar* nodeUniqueID) = 0;
              virtual void requireLock(const clients::User& user, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* reason) = 0;
              virtual void changeHardwareStatus(const clients::User& user, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, hardware::HardwareStatus newStatus) = 0;
              virtual void changeAllHardwareStatus(const clients::User& user, const CORBA::WChar* nodeUniqueID, hardware::HardwareStatus newStatus) = 0;
              virtual hardware::FieldData* getParameterValue(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const CORBA::WChar* fieldUniqueID) = 0;
              virtual hardware::FieldDataList* getParameterValues(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID) = 0;
              virtual hardware::ExtraLib* getExtraLibs(const CORBA::WChar* nodeUniqueID, const util::TimeStamp& lastDownload) = 0;
              virtual void configure(const clients::User& usr, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const hardware::FieldDataList& data) = 0;
              virtual hardware::ConnectionStatus getNodeConnectionStatus(const CORBA::WChar* nodeUniqueID) = 0;
              virtual void changeNodeConnectionStatus(const clients::User& usr, const CORBA::WChar* nodeUniqueID, hardware::ConnectionStatus newStatus) = 0;
              virtual hardware::ConnectionList* getAllHardwareConnectionStatus(const CORBA::WChar* nodeUniqueID) = 0;
              virtual hardware::ConnectionStatus getHardwareConnectionStatus(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID) = 0;
              virtual void changeHardwareConnectionStatus(const clients::User& usr, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, hardware::ConnectionStatus newStatus) = 0;
              virtual hardware::ConnectionList* getAllParametersConnectionStatus(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID) = 0;
              virtual hardware::ConnectionStatus getParameterConnectionStatus(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID) = 0;
              virtual void changeParameterConnectionStatus(const clients::User& usr, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, hardware::ConnectionStatus newStatus) = 0;
              virtual hardware::TransferFunction* getTransferFunction(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID) = 0;
              virtual void setTransferFunction(const clients::User& usr, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const hardware::TransferFunction& tf) = 0;
              virtual void connectionStatusChanged(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID) = 0;
              virtual CORBA::Boolean isUserAllowed(const clients::User& usr, security::SecurityOperations oper, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID) = 0;
              virtual clients::UserList* getConnectedUsers() = 0;
              virtual CORBA::Boolean lock(const clients::User& usr, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID) = 0;
              virtual CORBA::Boolean unlock(const clients::User& usr, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID) = 0;
              virtual void eventEditLock(const clients::User& usr) = 0;
              virtual void eventEditUnLock(const clients::User& usr) = 0;
              virtual void hardwareListChanged(const CORBA::WChar* nodeUniqueID) = 0;
              virtual CORBA::Boolean isEventEditLocked() = 0;
              virtual CORBA::WChar* getXMLEvents() = 0;
              virtual hardware::EventList* getLastEventTable() = 0;
              virtual void setEventTable(const clients::User& usr, const hardware::EventList& evtList) = 0;
              virtual void fireEventTable(const CORBA::WChar* nodeUniqueID, const hardware::EventList& evtList) = 0;
              virtual void newEventListAdded(const hardware::EventList& evtList) = 0;
              virtual void abort(const clients::User& usr) = 0;
              virtual void hardwareStatusChange(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, hardware::HardwareStatus newStatus) = 0;
              virtual void nodeStatusChange(const CORBA::WChar* nodeUniqueID, hardware::NodeStatus newStatus) = 0;
              virtual hardware::NodeStatus getNodeStatus(const CORBA::WChar* nodeUniqueID) = 0;
              virtual hardware::HardwareStatusList* getAllHardwareStatus(const CORBA::WChar* nodeUniqueID) = 0;
              virtual util::TimeStamp getCurrentTime() = 0;
              virtual void newDataAvailable(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const db::Data& data) = 0;
              virtual void newDataStored(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const hardware::EventList& eList, const util::TimeStamp& tstart, const util::TimeStamp& tend) = 0;
              virtual db::DataList* getData(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, CORBA::LongLong event_id, const CORBA::WChar* event_name_id) = 0;
              virtual db::DataList* getDataFromTime(const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const util::TimeStamp& tstart, const util::TimeStamp& tend) = 0;
              virtual CORBA::WChar* getPluginsXML() = 0;
              virtual clients::ProfileList* getAllPublicProfiles() = 0;
              virtual clients::ProfileList* getAllUserProfiles(const clients::User& usr) = 0;
              virtual void saveProfile(const clients::User& usr, const clients::Profile& prof) = 0;
              virtual void deleteProfile(const clients::User& usr, const clients::Profile& prof) = 0;
              virtual void userPropertyChanged(const CORBA::WChar* username, const CORBA::WChar* propName, CORBA::Boolean propValue) = 0;
              virtual void shareData(const CORBA::WChar* userFrom, const util::StringList& usersTo, const CORBA::WChar* nodeUniqueID, const CORBA::WChar* hardwareUniqueID, const CORBA::WChar* parameterUniqueID, const CORBA::WChar* pluginclassloc, const util::TimeStamp& tstart, const util::TimeStamp& tend) = 0;
              virtual void kickUser(const clients::User& administrator, const CORBA::WChar* userToKick, const CORBA::WChar* reason) = 0;
              virtual void ping() = 0;
              virtual hardware::NameInfoList* getNodesNames(const util::StringList& nodeUIDs) = 0;
              virtual hardware::NameInfoList* getHardwareAndParameterNames(const CORBA::WChar* nodeUID, const util::StringList& hwUIDs) = 0;
              virtual void changeName(const clients::User& usr, const hardware::NameInfo& ninfo) = 0;
              virtual void nameChanged(const hardware::NameInfo& ninfo) = 0;
              virtual void addUser(const clients::User& administrator, const clients::User& usr, const clients::UserInformations& usrInfo) = 0;
              virtual void removeUser(const clients::User& administrator, const CORBA::WChar* username) = 0;
              virtual void editUser(const clients::User& administrator, const clients::User& usr) = 0;
              virtual void editUserInformations(const clients::User& administrator, const clients::UserInformations& usrInfos) = 0;
              virtual clients::UserInformations* getUserInformations(const CORBA::WChar* username) = 0;
              virtual util::StringList* getAllUsers() = 0;
              virtual clients::User* getUser(const clients::User& administrator, const CORBA::WChar* username) = 0;
              virtual void changePassword(const clients::User& user, const util::CharArray& password) = 0;
              virtual void addInstitution(const clients::User& administrator, const clients::Institution& institute) = 0;
              virtual void removeInstitution(const clients::User& administrator, const CORBA::WChar* name) = 0;
              virtual void editInstitution(const clients::User& administrator, const clients::Institution& institute) = 0;
              virtual util::StringList* getAllInstitutions() = 0;
              virtual clients::Institution* getInstitution(const CORBA::WChar* name) = 0;
              virtual CORBA::WChar* getGroupsXML() = 0;
              virtual void updateGroupsXML(const clients::User& administrator, const CORBA::WChar* xml) = 0;
              virtual util::CommentList* getComments(const util::TimeStamp& from, const util::TimeStamp& to) = 0;
              virtual util::CommentList* getLastComments(CORBA::Short number) = 0;
              virtual void addComment(const util::Comment& newComment) = 0;
              virtual void editComment(const util::Comment& toEdit, const util::Comment& toReplace) = 0;
              virtual void removeComment(const util::Comment& toRemove) = 0;
              virtual void commentAdded(const util::Comment& newComment) = 0;
              virtual void commentEdited(const util::Comment& toEdit, const util::Comment& toReplace) = 0;
              virtual void commentRemoved(const util::Comment& toRemove) = 0;
              
            public:  // Really protected, workaround for xlC
              virtual _CORBA_Boolean _dispatch(omniCallHandle&);

            private:
              virtual void* _ptrToInterface(const char*);
              virtual const char* _mostDerivedRepoId();
              
            };


#ifndef __org_mcfn_mscad_mcore_mcorba_mserver_mCentralServerRegister__
#define __org_mcfn_mscad_mcore_mcorba_mserver_mCentralServerRegister__

            class CentralServerRegister;
            class _objref_CentralServerRegister;
            class _impl_CentralServerRegister;
            
            typedef _objref_CentralServerRegister* CentralServerRegister_ptr;
            typedef CentralServerRegister_ptr CentralServerRegisterRef;

            class CentralServerRegister_Helper {
            public:
              typedef CentralServerRegister_ptr _ptr_type;

              static _ptr_type _nil();
              static _CORBA_Boolean is_nil(_ptr_type);
              static void release(_ptr_type);
              static void duplicate(_ptr_type);
              static void marshalObjRef(_ptr_type, cdrStream&);
              static _ptr_type unmarshalObjRef(cdrStream&);
            };

            typedef _CORBA_ObjRef_Var<_objref_CentralServerRegister, CentralServerRegister_Helper> CentralServerRegister_var;
            typedef _CORBA_ObjRef_OUT_arg<_objref_CentralServerRegister,CentralServerRegister_Helper > CentralServerRegister_out;

#endif

            // interface CentralServerRegister
            class CentralServerRegister {
            public:
              // Declarations for this interface type.
              typedef CentralServerRegister_ptr _ptr_type;
              typedef CentralServerRegister_var _var_type;

              static _ptr_type _duplicate(_ptr_type);
              static _ptr_type _narrow(CORBA::Object_ptr);
              static _ptr_type _unchecked_narrow(CORBA::Object_ptr);
              
              static _ptr_type _nil();

              static inline void _marshalObjRef(_ptr_type, cdrStream&);

              static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
                omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
                if (o)
                  return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
                else
                  return _nil();
              }

              static _core_attr const char* _PD_repoId;

              // Other IDL defined within this scope.
              
            };

            class _objref_CentralServerRegister :
              public virtual CORBA::Object,
              public virtual omniObjRef
            {
            public:
              CentralServer_ptr registerNode(const CORBA::WChar* publicKey, hardware::Node_ptr node);
              CentralServer_ptr registerClient(clients::Client_ptr c);
              void unregisterNode(hardware::Node_ptr node);
              void unregisterClient(clients::Client_ptr c);
              CentralServer_ptr registerDBController(const CORBA::WChar* publicKey, db::Database_ptr db);
              void requireRegister(const clients::User& usr, const clients::UserInformations& usrInfo);

              inline _objref_CentralServerRegister()  { _PR_setobj(0); }  // nil
              _objref_CentralServerRegister(omniIOR*, omniIdentity*);

            protected:
              virtual ~_objref_CentralServerRegister();

              
            private:
              virtual void* _ptrToObjRef(const char*);

              _objref_CentralServerRegister(const _objref_CentralServerRegister&);
              _objref_CentralServerRegister& operator = (const _objref_CentralServerRegister&);
              // not implemented

              friend class CentralServerRegister;
            };

            class _pof_CentralServerRegister : public _OMNI_NS(proxyObjectFactory) {
            public:
              inline _pof_CentralServerRegister() : _OMNI_NS(proxyObjectFactory)(CentralServerRegister::_PD_repoId) {}
              virtual ~_pof_CentralServerRegister();

              virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
              virtual _CORBA_Boolean is_a(const char*) const;
            };

            class _impl_CentralServerRegister :
              public virtual omniServant
            {
            public:
              virtual ~_impl_CentralServerRegister();

              virtual CentralServer_ptr registerNode(const CORBA::WChar* publicKey, hardware::Node_ptr node) = 0;
              virtual CentralServer_ptr registerClient(clients::Client_ptr c) = 0;
              virtual void unregisterNode(hardware::Node_ptr node) = 0;
              virtual void unregisterClient(clients::Client_ptr c) = 0;
              virtual CentralServer_ptr registerDBController(const CORBA::WChar* publicKey, db::Database_ptr db) = 0;
              virtual void requireRegister(const clients::User& usr, const clients::UserInformations& usrInfo) = 0;
              
            public:  // Really protected, workaround for xlC
              virtual _CORBA_Boolean _dispatch(omniCallHandle&);

            private:
              virtual void* _ptrToInterface(const char*);
              virtual const char* _mostDerivedRepoId();
              
            };


          _CORBA_MODULE_END

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_org
_CORBA_MODULE_BEG

  _CORBA_MODULE cfn
  _CORBA_MODULE_BEG

    _CORBA_MODULE scad
    _CORBA_MODULE_BEG

      _CORBA_MODULE core
      _CORBA_MODULE_BEG

        _CORBA_MODULE corba
        _CORBA_MODULE_BEG

          _CORBA_MODULE hardware
          _CORBA_MODULE_BEG

          _CORBA_MODULE_END

          _CORBA_MODULE db
          _CORBA_MODULE_BEG

            class Database :
              public virtual org::cfn::scad::core::corba::db::_impl_Database,
              public virtual PortableServer::ServantBase
            {
            public:
              virtual ~Database();

              inline ::org::cfn::scad::core::corba::db::Database_ptr _this() {
                return (::org::cfn::scad::core::corba::db::Database_ptr) _do_this(::org::cfn::scad::core::corba::db::Database::_PD_repoId);
              }
            };

          _CORBA_MODULE_END

          _CORBA_MODULE security
          _CORBA_MODULE_BEG

          _CORBA_MODULE_END

          _CORBA_MODULE clients
          _CORBA_MODULE_BEG

          _CORBA_MODULE_END

          _CORBA_MODULE hardware
          _CORBA_MODULE_BEG

            class Node :
              public virtual org::cfn::scad::core::corba::hardware::_impl_Node,
              public virtual PortableServer::ServantBase
            {
            public:
              virtual ~Node();

              inline ::org::cfn::scad::core::corba::hardware::Node_ptr _this() {
                return (::org::cfn::scad::core::corba::hardware::Node_ptr) _do_this(::org::cfn::scad::core::corba::hardware::Node::_PD_repoId);
              }
            };

          _CORBA_MODULE_END

          _CORBA_MODULE clients
          _CORBA_MODULE_BEG

            class Client :
              public virtual org::cfn::scad::core::corba::clients::_impl_Client,
              public virtual PortableServer::ServantBase
            {
            public:
              virtual ~Client();

              inline ::org::cfn::scad::core::corba::clients::Client_ptr _this() {
                return (::org::cfn::scad::core::corba::clients::Client_ptr) _do_this(::org::cfn::scad::core::corba::clients::Client::_PD_repoId);
              }
            };

          _CORBA_MODULE_END

          _CORBA_MODULE server
          _CORBA_MODULE_BEG

            class CentralServer :
              public virtual org::cfn::scad::core::corba::server::_impl_CentralServer,
              public virtual PortableServer::ServantBase
            {
            public:
              virtual ~CentralServer();

              inline ::org::cfn::scad::core::corba::server::CentralServer_ptr _this() {
                return (::org::cfn::scad::core::corba::server::CentralServer_ptr) _do_this(::org::cfn::scad::core::corba::server::CentralServer::_PD_repoId);
              }
            };

            class CentralServerRegister :
              public virtual org::cfn::scad::core::corba::server::_impl_CentralServerRegister,
              public virtual PortableServer::ServantBase
            {
            public:
              virtual ~CentralServerRegister();

              inline ::org::cfn::scad::core::corba::server::CentralServerRegister_ptr _this() {
                return (::org::cfn::scad::core::corba::server::CentralServerRegister_ptr) _do_this(::org::cfn::scad::core::corba::server::CentralServerRegister::_PD_repoId);
              }
            };

          _CORBA_MODULE_END

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE OBV_org
_CORBA_MODULE_BEG

  _CORBA_MODULE cfn
  _CORBA_MODULE_BEG

    _CORBA_MODULE scad
    _CORBA_MODULE_BEG

      _CORBA_MODULE core
      _CORBA_MODULE_BEG

        _CORBA_MODULE corba
        _CORBA_MODULE_BEG

          _CORBA_MODULE hardware
          _CORBA_MODULE_BEG

          _CORBA_MODULE_END

          _CORBA_MODULE db
          _CORBA_MODULE_BEG

          _CORBA_MODULE_END

          _CORBA_MODULE security
          _CORBA_MODULE_BEG

          _CORBA_MODULE_END

          _CORBA_MODULE clients
          _CORBA_MODULE_BEG

          _CORBA_MODULE_END

          _CORBA_MODULE hardware
          _CORBA_MODULE_BEG

          _CORBA_MODULE_END

          _CORBA_MODULE clients
          _CORBA_MODULE_BEG

          _CORBA_MODULE_END

          _CORBA_MODULE server
          _CORBA_MODULE_BEG

          _CORBA_MODULE_END

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

inline void operator >>=(org::cfn::scad::core::corba::security::SecurityError _e, cdrStream& s) {
  ::operator>>=((CORBA::ULong)_e, s);
}

inline void operator <<= (org::cfn::scad::core::corba::security::SecurityError& _e, cdrStream& s) {
  CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= org::cfn::scad::core::corba::security::UNKWOWN) {
    _e = (org::cfn::scad::core::corba::security::SecurityError) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(org::cfn::scad::core::corba::security::SecurityOperations _e, cdrStream& s) {
  ::operator>>=((CORBA::ULong)_e, s);
}

inline void operator <<= (org::cfn::scad::core::corba::security::SecurityOperations& _e, cdrStream& s) {
  CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= org::cfn::scad::core::corba::security::REMOVE_COMMENT) {
    _e = (org::cfn::scad::core::corba::security::SecurityOperations) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(org::cfn::scad::core::corba::clients::Profession _e, cdrStream& s) {
  ::operator>>=((CORBA::ULong)_e, s);
}

inline void operator <<= (org::cfn::scad::core::corba::clients::Profession& _e, cdrStream& s) {
  CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= org::cfn::scad::core::corba::clients::OTHER) {
    _e = (org::cfn::scad::core::corba::clients::Profession) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(org::cfn::scad::core::corba::hardware::NodeStatus _e, cdrStream& s) {
  ::operator>>=((CORBA::ULong)_e, s);
}

inline void operator <<= (org::cfn::scad::core::corba::hardware::NodeStatus& _e, cdrStream& s) {
  CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= org::cfn::scad::core::corba::hardware::TESTING) {
    _e = (org::cfn::scad::core::corba::hardware::NodeStatus) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(org::cfn::scad::core::corba::hardware::HardwareStatus _e, cdrStream& s) {
  ::operator>>=((CORBA::ULong)_e, s);
}

inline void operator <<= (org::cfn::scad::core::corba::hardware::HardwareStatus& _e, cdrStream& s) {
  CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= org::cfn::scad::core::corba::hardware::UNKNOWN) {
    _e = (org::cfn::scad::core::corba::hardware::HardwareStatus) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(org::cfn::scad::core::corba::hardware::HardwareLockStatus _e, cdrStream& s) {
  ::operator>>=((CORBA::ULong)_e, s);
}

inline void operator <<= (org::cfn::scad::core::corba::hardware::HardwareLockStatus& _e, cdrStream& s) {
  CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= org::cfn::scad::core::corba::hardware::UNLOCKED) {
    _e = (org::cfn::scad::core::corba::hardware::HardwareLockStatus) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(org::cfn::scad::core::corba::hardware::ConnectionStatus _e, cdrStream& s) {
  ::operator>>=((CORBA::ULong)_e, s);
}

inline void operator <<= (org::cfn::scad::core::corba::hardware::ConnectionStatus& _e, cdrStream& s) {
  CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= org::cfn::scad::core::corba::hardware::DISCONNECTED) {
    _e = (org::cfn::scad::core::corba::hardware::ConnectionStatus) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(org::cfn::scad::core::corba::hardware::ConfigurationError _e, cdrStream& s) {
  ::operator>>=((CORBA::ULong)_e, s);
}

inline void operator <<= (org::cfn::scad::core::corba::hardware::ConfigurationError& _e, cdrStream& s) {
  CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= org::cfn::scad::core::corba::hardware::UNKWOWN) {
    _e = (org::cfn::scad::core::corba::hardware::ConfigurationError) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (CORBA::CompletionStatus)s.completion());
  }
}



inline void
org::cfn::scad::core::corba::db::Database::_marshalObjRef(::org::cfn::scad::core::corba::db::Database_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
org::cfn::scad::core::corba::hardware::Node::_marshalObjRef(::org::cfn::scad::core::corba::hardware::Node_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
org::cfn::scad::core::corba::clients::Client::_marshalObjRef(::org::cfn::scad::core::corba::clients::Client_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
org::cfn::scad::core::corba::server::CentralServer::_marshalObjRef(::org::cfn::scad::core::corba::server::CentralServer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
org::cfn::scad::core::corba::server::CentralServerRegister::_marshalObjRef(::org::cfn::scad::core::corba::server::CentralServerRegister_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_SCAD
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_SCAD
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_SCAD
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_SCAD
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_SCAD
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_SCAD
#endif

#endif  // __SCAD_hh__

